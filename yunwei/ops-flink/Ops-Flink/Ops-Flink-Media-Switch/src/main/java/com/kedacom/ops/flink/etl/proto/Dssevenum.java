// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dssevenum.proto

package com.kedacom.ops.flink.etl.proto;

public final class Dssevenum {
  private Dssevenum() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
  }
  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.CltDssEvent}
   */
  public enum CltDssEvent
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>CLT_DSS_CREATCLIENT_REQ = 0;</code>
     *
     * <pre>
     *client
     * </pre>
     */
    CLT_DSS_CREATCLIENT_REQ(0, 0),
    /**
     * <code>DSS_CLT_CREATCLIENT_ACK = 1;</code>
     */
    DSS_CLT_CREATCLIENT_ACK(1, 1),
    /**
     * <code>DSS_CLT_CREATCLIENT_NACK = 2;</code>
     */
    DSS_CLT_CREATCLIENT_NACK(2, 2),
    /**
     * <code>CLT_DSS_DESTROYCLIENT_REQ = 3;</code>
     */
    CLT_DSS_DESTROYCLIENT_REQ(3, 3),
    /**
     * <code>DSS_CLT_DESTROYCLIENT_ACK = 4;</code>
     */
    DSS_CLT_DESTROYCLIENT_ACK(4, 4),
    /**
     * <code>DSS_CLT_DESTROYCLIENT_NACK = 5;</code>
     */
    DSS_CLT_DESTROYCLIENT_NACK(5, 5),
    /**
     * <code>CLT_DSS_SYNCAPPLYLOCALPORT_REQ = 6;</code>
     *
     * <pre>
     *port	
     * </pre>
     */
    CLT_DSS_SYNCAPPLYLOCALPORT_REQ(6, 6),
    /**
     * <code>DSS_CLT_SYNCAPPLYLOCALPORT_ACK = 7;</code>
     */
    DSS_CLT_SYNCAPPLYLOCALPORT_ACK(7, 7),
    /**
     * <code>DSS_CLT_SYNCAPPLYLOCALPORT_NACK = 8;</code>
     */
    DSS_CLT_SYNCAPPLYLOCALPORT_NACK(8, 8),
    /**
     * <code>CLT_DSS_ASYNCAPPLYLOCALPORT_REQ = 9;</code>
     */
    CLT_DSS_ASYNCAPPLYLOCALPORT_REQ(9, 9),
    /**
     * <code>DSS_CLT_ASYNCAPPLYLOCALPORT_ACK = 10;</code>
     */
    DSS_CLT_ASYNCAPPLYLOCALPORT_ACK(10, 10),
    /**
     * <code>DSS_CLT_ASYNCAPPLYLOCALPORT_NACK = 11;</code>
     */
    DSS_CLT_ASYNCAPPLYLOCALPORT_NACK(11, 11),
    /**
     * <code>CLT_DSS_SYNCAPPLYCARRIERPORT_REQ = 12;</code>
     */
    CLT_DSS_SYNCAPPLYCARRIERPORT_REQ(12, 12),
    /**
     * <code>DSS_CLT_SYNCAPPLYCARRIERPORT_ACK = 13;</code>
     */
    DSS_CLT_SYNCAPPLYCARRIERPORT_ACK(13, 13),
    /**
     * <code>DSS_CLT_SYNCAPPLYCARRIERPORT_NACK = 14;</code>
     */
    DSS_CLT_SYNCAPPLYCARRIERPORT_NACK(14, 14),
    /**
     * <code>CLT_DSS_ASYNCAPPLYCARRIERPORT_REQ = 15;</code>
     */
    CLT_DSS_ASYNCAPPLYCARRIERPORT_REQ(15, 15),
    /**
     * <code>DSS_CLT_ASYNCAPPLYCARRIERPORT_ACK = 16;</code>
     */
    DSS_CLT_ASYNCAPPLYCARRIERPORT_ACK(16, 16),
    /**
     * <code>DSS_CLT_ASYNCAPPLYCARRIERPORT_NACK = 17;</code>
     */
    DSS_CLT_ASYNCAPPLYCARRIERPORT_NACK(17, 17),
    /**
     * <code>CLT_DSS_RELEASEPORT_REQ = 18;</code>
     */
    CLT_DSS_RELEASEPORT_REQ(18, 18),
    /**
     * <code>DSS_CLT_RELEASEPORT_ACK = 19;</code>
     */
    DSS_CLT_RELEASEPORT_ACK(19, 19),
    /**
     * <code>DSS_CLT_RELEASEPORT_NACK = 20;</code>
     */
    DSS_CLT_RELEASEPORT_NACK(20, 20),
    /**
     * <code>CLT_DSS_ADDSWITCH_REQ = 21;</code>
     *
     * <pre>
     *switch
     * </pre>
     */
    CLT_DSS_ADDSWITCH_REQ(21, 21),
    /**
     * <code>DSS_CLT_ADDSWITCH_ACK = 22;</code>
     */
    DSS_CLT_ADDSWITCH_ACK(22, 22),
    /**
     * <code>DSS_CLT_ADDSWITCH_NACK = 23;</code>
     */
    DSS_CLT_ADDSWITCH_NACK(23, 23),
    /**
     * <code>CLT_DSS_REMOVESWITCH_REQ = 24;</code>
     */
    CLT_DSS_REMOVESWITCH_REQ(24, 24),
    /**
     * <code>DSS_CLT_REMOVESWITCH_ACK = 25;</code>
     */
    DSS_CLT_REMOVESWITCH_ACK(25, 25),
    /**
     * <code>DSS_CLT_REMOVESWITCH_NACK = 26;</code>
     */
    DSS_CLT_REMOVESWITCH_NACK(26, 26),
    /**
     * <code>CLT_DSS_ADDM2ONESWITCH_REQ = 27;</code>
     */
    CLT_DSS_ADDM2ONESWITCH_REQ(27, 27),
    /**
     * <code>DSS_CLT_ADDM2ONESWITCH_ACK = 28;</code>
     */
    DSS_CLT_ADDM2ONESWITCH_ACK(28, 28),
    /**
     * <code>DSS_CLT_ADDM2ONESWITCH_NACK = 29;</code>
     */
    DSS_CLT_ADDM2ONESWITCH_NACK(29, 29),
    /**
     * <code>CLT_DSS_REMOVEM2ONESWITCH_REQ = 30;</code>
     */
    CLT_DSS_REMOVEM2ONESWITCH_REQ(30, 30),
    /**
     * <code>DSS_CLT_REMOVEM2ONESWITCH_ACK = 31;</code>
     */
    DSS_CLT_REMOVEM2ONESWITCH_ACK(31, 31),
    /**
     * <code>DSS_CLT_REMOVEM2ONESWITCH_NACK = 32;</code>
     */
    DSS_CLT_REMOVEM2ONESWITCH_NACK(32, 32),
    /**
     * <code>CLT_DSS_ADDDUMP_REQ = 33;</code>
     */
    CLT_DSS_ADDDUMP_REQ(33, 33),
    /**
     * <code>DSS_CLT_ADDDUMP_ACK = 34;</code>
     */
    DSS_CLT_ADDDUMP_ACK(34, 34),
    /**
     * <code>DSS_CLT_ADDDUMP_NACK = 35;</code>
     */
    DSS_CLT_ADDDUMP_NACK(35, 35),
    /**
     * <code>CLT_DSS_REMOVEDUMP_REQ = 36;</code>
     */
    CLT_DSS_REMOVEDUMP_REQ(36, 36),
    /**
     * <code>DSS_CLT_REMOVEDUMP_ACK = 37;</code>
     */
    DSS_CLT_REMOVEDUMP_ACK(37, 37),
    /**
     * <code>DSS_CLT_REMOVEDUMP_NACK = 38;</code>
     */
    DSS_CLT_REMOVEDUMP_NACK(38, 38),
    /**
     * <code>CLT_DSS_SYNCADDBRIDGE_REQ = 39;</code>
     *
     * <pre>
     *bridge
     * </pre>
     */
    CLT_DSS_SYNCADDBRIDGE_REQ(39, 39),
    /**
     * <code>DSS_CLT_SYNCADDBRIDGE_ACK = 40;</code>
     */
    DSS_CLT_SYNCADDBRIDGE_ACK(40, 40),
    /**
     * <code>DSS_CLT_SYNCADDBRIDGE_NACK = 41;</code>
     */
    DSS_CLT_SYNCADDBRIDGE_NACK(41, 41),
    /**
     * <code>CLT_DSS_ASYNCADDBRIDGE_REQ = 42;</code>
     */
    CLT_DSS_ASYNCADDBRIDGE_REQ(42, 42),
    /**
     * <code>DSS_CLT_ASYNCADDBRIDGE_ACK = 43;</code>
     */
    DSS_CLT_ASYNCADDBRIDGE_ACK(43, 43),
    /**
     * <code>DSS_CLT_ASYNCADDBRIDGE_NACK = 44;</code>
     */
    DSS_CLT_ASYNCADDBRIDGE_NACK(44, 44),
    /**
     * <code>CLT_DSS_REMOVEBRIDGE_REQ = 45;</code>
     */
    CLT_DSS_REMOVEBRIDGE_REQ(45, 45),
    /**
     * <code>DSS_CLT_REMOVEBRIDGE_ACK = 46;</code>
     */
    DSS_CLT_REMOVEBRIDGE_ACK(46, 46),
    /**
     * <code>DSS_CLT_REMOVEBRIDGE_NACK = 47;</code>
     */
    DSS_CLT_REMOVEBRIDGE_NACK(47, 47),
    /**
     * <code>CLT_DSS_SENDTOBRIDGE_REQ = 48;</code>
     */
    CLT_DSS_SENDTOBRIDGE_REQ(48, 48),
    /**
     * <code>DSS_CLT_SENDTOBRIDGE_ACK = 49;</code>
     */
    DSS_CLT_SENDTOBRIDGE_ACK(49, 49),
    /**
     * <code>DSS_CLT_SENDTOBRIDGE_NACK = 50;</code>
     */
    DSS_CLT_SENDTOBRIDGE_NACK(50, 50),
    /**
     * <code>CLT_DSS_STOPSENDTOBRIDGE_REQ = 51;</code>
     */
    CLT_DSS_STOPSENDTOBRIDGE_REQ(51, 51),
    /**
     * <code>DSS_CLT_STOPSENDTOBRIDGE_ACK = 52;</code>
     */
    DSS_CLT_STOPSENDTOBRIDGE_ACK(52, 52),
    /**
     * <code>DSS_CLT_STOPSENDTOBRIDGE_NACK = 53;</code>
     */
    DSS_CLT_STOPSENDTOBRIDGE_NACK(53, 53),
    /**
     * <code>CLT_DSS_RECEIVEFROMBRIDGE_REQ = 54;</code>
     */
    CLT_DSS_RECEIVEFROMBRIDGE_REQ(54, 54),
    /**
     * <code>DSS_CLT_RECEIVEFROMBRIDGE_ACK = 55;</code>
     */
    DSS_CLT_RECEIVEFROMBRIDGE_ACK(55, 55),
    /**
     * <code>DSS_CLT_RECEIVEFROMBRIDGE_NACK = 56;</code>
     */
    DSS_CLT_RECEIVEFROMBRIDGE_NACK(56, 56),
    /**
     * <code>CLT_DSS_STOPRECEIVEFROMBRIDGE_REQ = 57;</code>
     */
    CLT_DSS_STOPRECEIVEFROMBRIDGE_REQ(57, 57),
    /**
     * <code>DSS_CLT_STOPRECEIVEFROMBRIDGE_ACK = 58;</code>
     */
    DSS_CLT_STOPRECEIVEFROMBRIDGE_ACK(58, 58),
    /**
     * <code>DSS_CLT_STOPRECEIVEFROMBRIDGE_NACK = 59;</code>
     */
    DSS_CLT_STOPRECEIVEFROMBRIDGE_NACK(59, 59),
    /**
     * <code>DSS_CLT_SRVLOST_NTF = 60;</code>
     */
    DSS_CLT_SRVLOST_NTF(60, 60),
    /**
     * <code>DSS_CLT_PING = 61;</code>
     */
    DSS_CLT_PING(61, 61),
    /**
     * <code>CLT_DSS_PONG = 62;</code>
     */
    CLT_DSS_PONG(62, 62),
    /**
     * <code>CLT_DSS_ALIVEDETECT_REQ = 63;</code>
     */
    CLT_DSS_ALIVEDETECT_REQ(63, 63),
    /**
     * <code>DSS_CLT_ALIVEDETECT_RSP = 64;</code>
     */
    DSS_CLT_ALIVEDETECT_RSP(64, 64),
    /**
     * <code>DSS_CLT_SRVREGISTER_NTF = 65;</code>
     */
    DSS_CLT_SRVREGISTER_NTF(65, 65),
    /**
     * <code>CLT_DSS_CONNECTMASTER_REQ = 66;</code>
     */
    CLT_DSS_CONNECTMASTER_REQ(66, 66),
    /**
     * <code>DSS_CLT_CONNECTMASTER_ACK = 67;</code>
     */
    DSS_CLT_CONNECTMASTER_ACK(67, 67),
    /**
     * <code>DSS_CLT_CONNECTMASTER_NACK = 68;</code>
     */
    DSS_CLT_CONNECTMASTER_NACK(68, 68),
    /**
     * <code>DSS_CLT_PONG = 69;</code>
     */
    DSS_CLT_PONG(69, 69),
    /**
     * <code>CLT_DSS_PING = 70;</code>
     */
    CLT_DSS_PING(70, 70),
    /**
     * <code>CLT_DSS_GETLOSTRATEBYPORT_REQ = 71;</code>
     */
    CLT_DSS_GETLOSTRATEBYPORT_REQ(71, 71),
    /**
     * <code>DSS_CLT_GETLOSTRATEBYPORT_REPLY = 72;</code>
     */
    DSS_CLT_GETLOSTRATEBYPORT_REPLY(72, 72),
    /**
     * <code>CLT_DSS_BINDWORKERTOMEETING_REQ = 73;</code>
     */
    CLT_DSS_BINDWORKERTOMEETING_REQ(73, 73),
    /**
     * <code>DSS_CLT_BINDWORKERTOMEETING_ACK = 74;</code>
     */
    DSS_CLT_BINDWORKERTOMEETING_ACK(74, 74),
    /**
     * <code>DSS_CLT_BINDWORKERTOMEETING_NACK = 75;</code>
     */
    DSS_CLT_BINDWORKERTOMEETING_NACK(75, 75),
    /**
     * <code>CLT_DSS_UNBINDWORKERFROMMEETING_REQ = 76;</code>
     */
    CLT_DSS_UNBINDWORKERFROMMEETING_REQ(76, 76),
    /**
     * <code>DSS_CLT_UNBINDWORKERFROMMEETING_ACK = 78;</code>
     */
    DSS_CLT_UNBINDWORKERFROMMEETING_ACK(77, 78),
    /**
     * <code>DSS_CLT_UNBINDWORKERFROMMEETING_NACK = 79;</code>
     */
    DSS_CLT_UNBINDWORKERFROMMEETING_NACK(78, 79),
    /**
     * <code>DSS_CLT_REMOVECLIENT_NTF = 80;</code>
     */
    DSS_CLT_REMOVECLIENT_NTF(79, 80),
    /**
     * <code>CLT_DSS_SYNCAPPLYPORT_REQ = 81;</code>
     */
    CLT_DSS_SYNCAPPLYPORT_REQ(80, 81),
    /**
     * <code>DSS_CLT_SYNCAPPLYPORT_ACK = 82;</code>
     */
    DSS_CLT_SYNCAPPLYPORT_ACK(81, 82),
    /**
     * <code>DSS_CLT_SYNCAPPLYPORT_NACK = 83;</code>
     */
    DSS_CLT_SYNCAPPLYPORT_NACK(82, 83),
    /**
     * <code>CLT_DSS_ASYNCAPPLYPORT_REQ = 84;</code>
     */
    CLT_DSS_ASYNCAPPLYPORT_REQ(83, 84),
    /**
     * <code>DSS_CLT_ASYNCAPPLYPORT_ACK = 85;</code>
     */
    DSS_CLT_ASYNCAPPLYPORT_ACK(84, 85),
    /**
     * <code>DSS_CLT_ASYNCAPPLYPORT_NACK = 86;</code>
     */
    DSS_CLT_ASYNCAPPLYPORT_NACK(85, 86),
    /**
     * <code>DSS_CLT_BRIDGESPEAKERREMOVED_NTF = 87;</code>
     */
    DSS_CLT_BRIDGESPEAKERREMOVED_NTF(86, 87),
    /**
     * <code>CLT_DSS_DESTROYCLIENTBYUUID_REQ = 88;</code>
     */
    CLT_DSS_DESTROYCLIENTBYUUID_REQ(87, 88),
    /**
     * <code>DSS_CLT_DESTROYCLIENTBYUUID_ACK = 89;</code>
     */
    DSS_CLT_DESTROYCLIENTBYUUID_ACK(88, 89),
    /**
     * <code>DSS_CLT_DESTROYCLIENTBYUUID_NACK = 90;</code>
     */
    DSS_CLT_DESTROYCLIENTBYUUID_NACK(89, 90),
    /**
     * <code>CLT_DSS_RELEASEPORTBYUUID_REQ = 91;</code>
     */
    CLT_DSS_RELEASEPORTBYUUID_REQ(90, 91),
    /**
     * <code>DSS_CLT_RELEASEPORTBYUUID_ACK = 92;</code>
     */
    DSS_CLT_RELEASEPORTBYUUID_ACK(91, 92),
    /**
     * <code>DSS_CLT_RELEASEPORTBYUUID_NACK = 93;</code>
     */
    DSS_CLT_RELEASEPORTBYUUID_NACK(92, 93),
    /**
     * <code>CLT_DSS_REMOVEBRIDGEBYUUID_REQ = 94;</code>
     */
    CLT_DSS_REMOVEBRIDGEBYUUID_REQ(93, 94),
    /**
     * <code>DSS_CLT_REMOVEBRIDGEBYUUID_ACK = 95;</code>
     */
    DSS_CLT_REMOVEBRIDGEBYUUID_ACK(94, 95),
    /**
     * <code>DSS_CLT_REMOVEBRIDGEBYUUID_NACK = 96;</code>
     */
    DSS_CLT_REMOVEBRIDGEBYUUID_NACK(95, 96),
    /**
     * <code>CLT_DSS_SRVLOST_NTFRSP = 97;</code>
     */
    CLT_DSS_SRVLOST_NTFRSP(96, 97),
    /**
     * <code>CLT_DSS_SRVREGISTER_NTFRSP = 98;</code>
     */
    CLT_DSS_SRVREGISTER_NTFRSP(97, 98),
    /**
     * <code>CLT_DSS_RELEASEPARTPORT_REQ = 99;</code>
     */
    CLT_DSS_RELEASEPARTPORT_REQ(98, 99),
    /**
     * <code>DSS_CLT_RELEASEPARPORT_ACK = 100;</code>
     */
    DSS_CLT_RELEASEPARPORT_ACK(99, 100),
    /**
     * <code>DSS_CLT_RELEASEPARPORT_NACK = 101;</code>
     */
    DSS_CLT_RELEASEPARPORT_NACK(100, 101),
    /**
     * <code>DSS_CLT_DYNAMICENCRPTYKEYLENSS_NTF = 102;</code>
     */
    DSS_CLT_DYNAMICENCRPTYKEYLENSS_NTF(101, 102),
    /**
     * <code>CLT_DSS_UPDATEDYNAMICENCRPTYKEY_CMD = 103;</code>
     */
    CLT_DSS_UPDATEDYNAMICENCRPTYKEY_CMD(102, 103),
    /**
     * <code>CLT_DSS_SET_EPMUTE_REQ = 104;</code>
     */
    CLT_DSS_SET_EPMUTE_REQ(103, 104),
    /**
     * <code>DSS_CLT_SET_EPMUTE_ACK = 105;</code>
     */
    DSS_CLT_SET_EPMUTE_ACK(104, 105),
    /**
     * <code>DSS_CLT_SET_EPMUTE_NACK = 106;</code>
     */
    DSS_CLT_SET_EPMUTE_NACK(105, 106),
    /**
     * <code>CLT_DSS_SET_EPSILENT_REQ = 107;</code>
     */
    CLT_DSS_SET_EPSILENT_REQ(106, 107),
    /**
     * <code>DSS_CLT_SET_EPSILENT_ACK = 108;</code>
     */
    DSS_CLT_SET_EPSILENT_ACK(107, 108),
    /**
     * <code>DSS_CLT_SET_EPSILENT_NACK = 109;</code>
     */
    DSS_CLT_SET_EPSILENT_NACK(108, 109),
    ;

    /**
     * <code>CLT_DSS_CREATCLIENT_REQ = 0;</code>
     *
     * <pre>
     *client
     * </pre>
     */
    public static final int CLT_DSS_CREATCLIENT_REQ_VALUE = 0;
    /**
     * <code>DSS_CLT_CREATCLIENT_ACK = 1;</code>
     */
    public static final int DSS_CLT_CREATCLIENT_ACK_VALUE = 1;
    /**
     * <code>DSS_CLT_CREATCLIENT_NACK = 2;</code>
     */
    public static final int DSS_CLT_CREATCLIENT_NACK_VALUE = 2;
    /**
     * <code>CLT_DSS_DESTROYCLIENT_REQ = 3;</code>
     */
    public static final int CLT_DSS_DESTROYCLIENT_REQ_VALUE = 3;
    /**
     * <code>DSS_CLT_DESTROYCLIENT_ACK = 4;</code>
     */
    public static final int DSS_CLT_DESTROYCLIENT_ACK_VALUE = 4;
    /**
     * <code>DSS_CLT_DESTROYCLIENT_NACK = 5;</code>
     */
    public static final int DSS_CLT_DESTROYCLIENT_NACK_VALUE = 5;
    /**
     * <code>CLT_DSS_SYNCAPPLYLOCALPORT_REQ = 6;</code>
     *
     * <pre>
     *port	
     * </pre>
     */
    public static final int CLT_DSS_SYNCAPPLYLOCALPORT_REQ_VALUE = 6;
    /**
     * <code>DSS_CLT_SYNCAPPLYLOCALPORT_ACK = 7;</code>
     */
    public static final int DSS_CLT_SYNCAPPLYLOCALPORT_ACK_VALUE = 7;
    /**
     * <code>DSS_CLT_SYNCAPPLYLOCALPORT_NACK = 8;</code>
     */
    public static final int DSS_CLT_SYNCAPPLYLOCALPORT_NACK_VALUE = 8;
    /**
     * <code>CLT_DSS_ASYNCAPPLYLOCALPORT_REQ = 9;</code>
     */
    public static final int CLT_DSS_ASYNCAPPLYLOCALPORT_REQ_VALUE = 9;
    /**
     * <code>DSS_CLT_ASYNCAPPLYLOCALPORT_ACK = 10;</code>
     */
    public static final int DSS_CLT_ASYNCAPPLYLOCALPORT_ACK_VALUE = 10;
    /**
     * <code>DSS_CLT_ASYNCAPPLYLOCALPORT_NACK = 11;</code>
     */
    public static final int DSS_CLT_ASYNCAPPLYLOCALPORT_NACK_VALUE = 11;
    /**
     * <code>CLT_DSS_SYNCAPPLYCARRIERPORT_REQ = 12;</code>
     */
    public static final int CLT_DSS_SYNCAPPLYCARRIERPORT_REQ_VALUE = 12;
    /**
     * <code>DSS_CLT_SYNCAPPLYCARRIERPORT_ACK = 13;</code>
     */
    public static final int DSS_CLT_SYNCAPPLYCARRIERPORT_ACK_VALUE = 13;
    /**
     * <code>DSS_CLT_SYNCAPPLYCARRIERPORT_NACK = 14;</code>
     */
    public static final int DSS_CLT_SYNCAPPLYCARRIERPORT_NACK_VALUE = 14;
    /**
     * <code>CLT_DSS_ASYNCAPPLYCARRIERPORT_REQ = 15;</code>
     */
    public static final int CLT_DSS_ASYNCAPPLYCARRIERPORT_REQ_VALUE = 15;
    /**
     * <code>DSS_CLT_ASYNCAPPLYCARRIERPORT_ACK = 16;</code>
     */
    public static final int DSS_CLT_ASYNCAPPLYCARRIERPORT_ACK_VALUE = 16;
    /**
     * <code>DSS_CLT_ASYNCAPPLYCARRIERPORT_NACK = 17;</code>
     */
    public static final int DSS_CLT_ASYNCAPPLYCARRIERPORT_NACK_VALUE = 17;
    /**
     * <code>CLT_DSS_RELEASEPORT_REQ = 18;</code>
     */
    public static final int CLT_DSS_RELEASEPORT_REQ_VALUE = 18;
    /**
     * <code>DSS_CLT_RELEASEPORT_ACK = 19;</code>
     */
    public static final int DSS_CLT_RELEASEPORT_ACK_VALUE = 19;
    /**
     * <code>DSS_CLT_RELEASEPORT_NACK = 20;</code>
     */
    public static final int DSS_CLT_RELEASEPORT_NACK_VALUE = 20;
    /**
     * <code>CLT_DSS_ADDSWITCH_REQ = 21;</code>
     *
     * <pre>
     *switch
     * </pre>
     */
    public static final int CLT_DSS_ADDSWITCH_REQ_VALUE = 21;
    /**
     * <code>DSS_CLT_ADDSWITCH_ACK = 22;</code>
     */
    public static final int DSS_CLT_ADDSWITCH_ACK_VALUE = 22;
    /**
     * <code>DSS_CLT_ADDSWITCH_NACK = 23;</code>
     */
    public static final int DSS_CLT_ADDSWITCH_NACK_VALUE = 23;
    /**
     * <code>CLT_DSS_REMOVESWITCH_REQ = 24;</code>
     */
    public static final int CLT_DSS_REMOVESWITCH_REQ_VALUE = 24;
    /**
     * <code>DSS_CLT_REMOVESWITCH_ACK = 25;</code>
     */
    public static final int DSS_CLT_REMOVESWITCH_ACK_VALUE = 25;
    /**
     * <code>DSS_CLT_REMOVESWITCH_NACK = 26;</code>
     */
    public static final int DSS_CLT_REMOVESWITCH_NACK_VALUE = 26;
    /**
     * <code>CLT_DSS_ADDM2ONESWITCH_REQ = 27;</code>
     */
    public static final int CLT_DSS_ADDM2ONESWITCH_REQ_VALUE = 27;
    /**
     * <code>DSS_CLT_ADDM2ONESWITCH_ACK = 28;</code>
     */
    public static final int DSS_CLT_ADDM2ONESWITCH_ACK_VALUE = 28;
    /**
     * <code>DSS_CLT_ADDM2ONESWITCH_NACK = 29;</code>
     */
    public static final int DSS_CLT_ADDM2ONESWITCH_NACK_VALUE = 29;
    /**
     * <code>CLT_DSS_REMOVEM2ONESWITCH_REQ = 30;</code>
     */
    public static final int CLT_DSS_REMOVEM2ONESWITCH_REQ_VALUE = 30;
    /**
     * <code>DSS_CLT_REMOVEM2ONESWITCH_ACK = 31;</code>
     */
    public static final int DSS_CLT_REMOVEM2ONESWITCH_ACK_VALUE = 31;
    /**
     * <code>DSS_CLT_REMOVEM2ONESWITCH_NACK = 32;</code>
     */
    public static final int DSS_CLT_REMOVEM2ONESWITCH_NACK_VALUE = 32;
    /**
     * <code>CLT_DSS_ADDDUMP_REQ = 33;</code>
     */
    public static final int CLT_DSS_ADDDUMP_REQ_VALUE = 33;
    /**
     * <code>DSS_CLT_ADDDUMP_ACK = 34;</code>
     */
    public static final int DSS_CLT_ADDDUMP_ACK_VALUE = 34;
    /**
     * <code>DSS_CLT_ADDDUMP_NACK = 35;</code>
     */
    public static final int DSS_CLT_ADDDUMP_NACK_VALUE = 35;
    /**
     * <code>CLT_DSS_REMOVEDUMP_REQ = 36;</code>
     */
    public static final int CLT_DSS_REMOVEDUMP_REQ_VALUE = 36;
    /**
     * <code>DSS_CLT_REMOVEDUMP_ACK = 37;</code>
     */
    public static final int DSS_CLT_REMOVEDUMP_ACK_VALUE = 37;
    /**
     * <code>DSS_CLT_REMOVEDUMP_NACK = 38;</code>
     */
    public static final int DSS_CLT_REMOVEDUMP_NACK_VALUE = 38;
    /**
     * <code>CLT_DSS_SYNCADDBRIDGE_REQ = 39;</code>
     *
     * <pre>
     *bridge
     * </pre>
     */
    public static final int CLT_DSS_SYNCADDBRIDGE_REQ_VALUE = 39;
    /**
     * <code>DSS_CLT_SYNCADDBRIDGE_ACK = 40;</code>
     */
    public static final int DSS_CLT_SYNCADDBRIDGE_ACK_VALUE = 40;
    /**
     * <code>DSS_CLT_SYNCADDBRIDGE_NACK = 41;</code>
     */
    public static final int DSS_CLT_SYNCADDBRIDGE_NACK_VALUE = 41;
    /**
     * <code>CLT_DSS_ASYNCADDBRIDGE_REQ = 42;</code>
     */
    public static final int CLT_DSS_ASYNCADDBRIDGE_REQ_VALUE = 42;
    /**
     * <code>DSS_CLT_ASYNCADDBRIDGE_ACK = 43;</code>
     */
    public static final int DSS_CLT_ASYNCADDBRIDGE_ACK_VALUE = 43;
    /**
     * <code>DSS_CLT_ASYNCADDBRIDGE_NACK = 44;</code>
     */
    public static final int DSS_CLT_ASYNCADDBRIDGE_NACK_VALUE = 44;
    /**
     * <code>CLT_DSS_REMOVEBRIDGE_REQ = 45;</code>
     */
    public static final int CLT_DSS_REMOVEBRIDGE_REQ_VALUE = 45;
    /**
     * <code>DSS_CLT_REMOVEBRIDGE_ACK = 46;</code>
     */
    public static final int DSS_CLT_REMOVEBRIDGE_ACK_VALUE = 46;
    /**
     * <code>DSS_CLT_REMOVEBRIDGE_NACK = 47;</code>
     */
    public static final int DSS_CLT_REMOVEBRIDGE_NACK_VALUE = 47;
    /**
     * <code>CLT_DSS_SENDTOBRIDGE_REQ = 48;</code>
     */
    public static final int CLT_DSS_SENDTOBRIDGE_REQ_VALUE = 48;
    /**
     * <code>DSS_CLT_SENDTOBRIDGE_ACK = 49;</code>
     */
    public static final int DSS_CLT_SENDTOBRIDGE_ACK_VALUE = 49;
    /**
     * <code>DSS_CLT_SENDTOBRIDGE_NACK = 50;</code>
     */
    public static final int DSS_CLT_SENDTOBRIDGE_NACK_VALUE = 50;
    /**
     * <code>CLT_DSS_STOPSENDTOBRIDGE_REQ = 51;</code>
     */
    public static final int CLT_DSS_STOPSENDTOBRIDGE_REQ_VALUE = 51;
    /**
     * <code>DSS_CLT_STOPSENDTOBRIDGE_ACK = 52;</code>
     */
    public static final int DSS_CLT_STOPSENDTOBRIDGE_ACK_VALUE = 52;
    /**
     * <code>DSS_CLT_STOPSENDTOBRIDGE_NACK = 53;</code>
     */
    public static final int DSS_CLT_STOPSENDTOBRIDGE_NACK_VALUE = 53;
    /**
     * <code>CLT_DSS_RECEIVEFROMBRIDGE_REQ = 54;</code>
     */
    public static final int CLT_DSS_RECEIVEFROMBRIDGE_REQ_VALUE = 54;
    /**
     * <code>DSS_CLT_RECEIVEFROMBRIDGE_ACK = 55;</code>
     */
    public static final int DSS_CLT_RECEIVEFROMBRIDGE_ACK_VALUE = 55;
    /**
     * <code>DSS_CLT_RECEIVEFROMBRIDGE_NACK = 56;</code>
     */
    public static final int DSS_CLT_RECEIVEFROMBRIDGE_NACK_VALUE = 56;
    /**
     * <code>CLT_DSS_STOPRECEIVEFROMBRIDGE_REQ = 57;</code>
     */
    public static final int CLT_DSS_STOPRECEIVEFROMBRIDGE_REQ_VALUE = 57;
    /**
     * <code>DSS_CLT_STOPRECEIVEFROMBRIDGE_ACK = 58;</code>
     */
    public static final int DSS_CLT_STOPRECEIVEFROMBRIDGE_ACK_VALUE = 58;
    /**
     * <code>DSS_CLT_STOPRECEIVEFROMBRIDGE_NACK = 59;</code>
     */
    public static final int DSS_CLT_STOPRECEIVEFROMBRIDGE_NACK_VALUE = 59;
    /**
     * <code>DSS_CLT_SRVLOST_NTF = 60;</code>
     */
    public static final int DSS_CLT_SRVLOST_NTF_VALUE = 60;
    /**
     * <code>DSS_CLT_PING = 61;</code>
     */
    public static final int DSS_CLT_PING_VALUE = 61;
    /**
     * <code>CLT_DSS_PONG = 62;</code>
     */
    public static final int CLT_DSS_PONG_VALUE = 62;
    /**
     * <code>CLT_DSS_ALIVEDETECT_REQ = 63;</code>
     */
    public static final int CLT_DSS_ALIVEDETECT_REQ_VALUE = 63;
    /**
     * <code>DSS_CLT_ALIVEDETECT_RSP = 64;</code>
     */
    public static final int DSS_CLT_ALIVEDETECT_RSP_VALUE = 64;
    /**
     * <code>DSS_CLT_SRVREGISTER_NTF = 65;</code>
     */
    public static final int DSS_CLT_SRVREGISTER_NTF_VALUE = 65;
    /**
     * <code>CLT_DSS_CONNECTMASTER_REQ = 66;</code>
     */
    public static final int CLT_DSS_CONNECTMASTER_REQ_VALUE = 66;
    /**
     * <code>DSS_CLT_CONNECTMASTER_ACK = 67;</code>
     */
    public static final int DSS_CLT_CONNECTMASTER_ACK_VALUE = 67;
    /**
     * <code>DSS_CLT_CONNECTMASTER_NACK = 68;</code>
     */
    public static final int DSS_CLT_CONNECTMASTER_NACK_VALUE = 68;
    /**
     * <code>DSS_CLT_PONG = 69;</code>
     */
    public static final int DSS_CLT_PONG_VALUE = 69;
    /**
     * <code>CLT_DSS_PING = 70;</code>
     */
    public static final int CLT_DSS_PING_VALUE = 70;
    /**
     * <code>CLT_DSS_GETLOSTRATEBYPORT_REQ = 71;</code>
     */
    public static final int CLT_DSS_GETLOSTRATEBYPORT_REQ_VALUE = 71;
    /**
     * <code>DSS_CLT_GETLOSTRATEBYPORT_REPLY = 72;</code>
     */
    public static final int DSS_CLT_GETLOSTRATEBYPORT_REPLY_VALUE = 72;
    /**
     * <code>CLT_DSS_BINDWORKERTOMEETING_REQ = 73;</code>
     */
    public static final int CLT_DSS_BINDWORKERTOMEETING_REQ_VALUE = 73;
    /**
     * <code>DSS_CLT_BINDWORKERTOMEETING_ACK = 74;</code>
     */
    public static final int DSS_CLT_BINDWORKERTOMEETING_ACK_VALUE = 74;
    /**
     * <code>DSS_CLT_BINDWORKERTOMEETING_NACK = 75;</code>
     */
    public static final int DSS_CLT_BINDWORKERTOMEETING_NACK_VALUE = 75;
    /**
     * <code>CLT_DSS_UNBINDWORKERFROMMEETING_REQ = 76;</code>
     */
    public static final int CLT_DSS_UNBINDWORKERFROMMEETING_REQ_VALUE = 76;
    /**
     * <code>DSS_CLT_UNBINDWORKERFROMMEETING_ACK = 78;</code>
     */
    public static final int DSS_CLT_UNBINDWORKERFROMMEETING_ACK_VALUE = 78;
    /**
     * <code>DSS_CLT_UNBINDWORKERFROMMEETING_NACK = 79;</code>
     */
    public static final int DSS_CLT_UNBINDWORKERFROMMEETING_NACK_VALUE = 79;
    /**
     * <code>DSS_CLT_REMOVECLIENT_NTF = 80;</code>
     */
    public static final int DSS_CLT_REMOVECLIENT_NTF_VALUE = 80;
    /**
     * <code>CLT_DSS_SYNCAPPLYPORT_REQ = 81;</code>
     */
    public static final int CLT_DSS_SYNCAPPLYPORT_REQ_VALUE = 81;
    /**
     * <code>DSS_CLT_SYNCAPPLYPORT_ACK = 82;</code>
     */
    public static final int DSS_CLT_SYNCAPPLYPORT_ACK_VALUE = 82;
    /**
     * <code>DSS_CLT_SYNCAPPLYPORT_NACK = 83;</code>
     */
    public static final int DSS_CLT_SYNCAPPLYPORT_NACK_VALUE = 83;
    /**
     * <code>CLT_DSS_ASYNCAPPLYPORT_REQ = 84;</code>
     */
    public static final int CLT_DSS_ASYNCAPPLYPORT_REQ_VALUE = 84;
    /**
     * <code>DSS_CLT_ASYNCAPPLYPORT_ACK = 85;</code>
     */
    public static final int DSS_CLT_ASYNCAPPLYPORT_ACK_VALUE = 85;
    /**
     * <code>DSS_CLT_ASYNCAPPLYPORT_NACK = 86;</code>
     */
    public static final int DSS_CLT_ASYNCAPPLYPORT_NACK_VALUE = 86;
    /**
     * <code>DSS_CLT_BRIDGESPEAKERREMOVED_NTF = 87;</code>
     */
    public static final int DSS_CLT_BRIDGESPEAKERREMOVED_NTF_VALUE = 87;
    /**
     * <code>CLT_DSS_DESTROYCLIENTBYUUID_REQ = 88;</code>
     */
    public static final int CLT_DSS_DESTROYCLIENTBYUUID_REQ_VALUE = 88;
    /**
     * <code>DSS_CLT_DESTROYCLIENTBYUUID_ACK = 89;</code>
     */
    public static final int DSS_CLT_DESTROYCLIENTBYUUID_ACK_VALUE = 89;
    /**
     * <code>DSS_CLT_DESTROYCLIENTBYUUID_NACK = 90;</code>
     */
    public static final int DSS_CLT_DESTROYCLIENTBYUUID_NACK_VALUE = 90;
    /**
     * <code>CLT_DSS_RELEASEPORTBYUUID_REQ = 91;</code>
     */
    public static final int CLT_DSS_RELEASEPORTBYUUID_REQ_VALUE = 91;
    /**
     * <code>DSS_CLT_RELEASEPORTBYUUID_ACK = 92;</code>
     */
    public static final int DSS_CLT_RELEASEPORTBYUUID_ACK_VALUE = 92;
    /**
     * <code>DSS_CLT_RELEASEPORTBYUUID_NACK = 93;</code>
     */
    public static final int DSS_CLT_RELEASEPORTBYUUID_NACK_VALUE = 93;
    /**
     * <code>CLT_DSS_REMOVEBRIDGEBYUUID_REQ = 94;</code>
     */
    public static final int CLT_DSS_REMOVEBRIDGEBYUUID_REQ_VALUE = 94;
    /**
     * <code>DSS_CLT_REMOVEBRIDGEBYUUID_ACK = 95;</code>
     */
    public static final int DSS_CLT_REMOVEBRIDGEBYUUID_ACK_VALUE = 95;
    /**
     * <code>DSS_CLT_REMOVEBRIDGEBYUUID_NACK = 96;</code>
     */
    public static final int DSS_CLT_REMOVEBRIDGEBYUUID_NACK_VALUE = 96;
    /**
     * <code>CLT_DSS_SRVLOST_NTFRSP = 97;</code>
     */
    public static final int CLT_DSS_SRVLOST_NTFRSP_VALUE = 97;
    /**
     * <code>CLT_DSS_SRVREGISTER_NTFRSP = 98;</code>
     */
    public static final int CLT_DSS_SRVREGISTER_NTFRSP_VALUE = 98;
    /**
     * <code>CLT_DSS_RELEASEPARTPORT_REQ = 99;</code>
     */
    public static final int CLT_DSS_RELEASEPARTPORT_REQ_VALUE = 99;
    /**
     * <code>DSS_CLT_RELEASEPARPORT_ACK = 100;</code>
     */
    public static final int DSS_CLT_RELEASEPARPORT_ACK_VALUE = 100;
    /**
     * <code>DSS_CLT_RELEASEPARPORT_NACK = 101;</code>
     */
    public static final int DSS_CLT_RELEASEPARPORT_NACK_VALUE = 101;
    /**
     * <code>DSS_CLT_DYNAMICENCRPTYKEYLENSS_NTF = 102;</code>
     */
    public static final int DSS_CLT_DYNAMICENCRPTYKEYLENSS_NTF_VALUE = 102;
    /**
     * <code>CLT_DSS_UPDATEDYNAMICENCRPTYKEY_CMD = 103;</code>
     */
    public static final int CLT_DSS_UPDATEDYNAMICENCRPTYKEY_CMD_VALUE = 103;
    /**
     * <code>CLT_DSS_SET_EPMUTE_REQ = 104;</code>
     */
    public static final int CLT_DSS_SET_EPMUTE_REQ_VALUE = 104;
    /**
     * <code>DSS_CLT_SET_EPMUTE_ACK = 105;</code>
     */
    public static final int DSS_CLT_SET_EPMUTE_ACK_VALUE = 105;
    /**
     * <code>DSS_CLT_SET_EPMUTE_NACK = 106;</code>
     */
    public static final int DSS_CLT_SET_EPMUTE_NACK_VALUE = 106;
    /**
     * <code>CLT_DSS_SET_EPSILENT_REQ = 107;</code>
     */
    public static final int CLT_DSS_SET_EPSILENT_REQ_VALUE = 107;
    /**
     * <code>DSS_CLT_SET_EPSILENT_ACK = 108;</code>
     */
    public static final int DSS_CLT_SET_EPSILENT_ACK_VALUE = 108;
    /**
     * <code>DSS_CLT_SET_EPSILENT_NACK = 109;</code>
     */
    public static final int DSS_CLT_SET_EPSILENT_NACK_VALUE = 109;


    public final int getNumber() { return value; }

    public static CltDssEvent valueOf(int value) {
      switch (value) {
        case 0: return CLT_DSS_CREATCLIENT_REQ;
        case 1: return DSS_CLT_CREATCLIENT_ACK;
        case 2: return DSS_CLT_CREATCLIENT_NACK;
        case 3: return CLT_DSS_DESTROYCLIENT_REQ;
        case 4: return DSS_CLT_DESTROYCLIENT_ACK;
        case 5: return DSS_CLT_DESTROYCLIENT_NACK;
        case 6: return CLT_DSS_SYNCAPPLYLOCALPORT_REQ;
        case 7: return DSS_CLT_SYNCAPPLYLOCALPORT_ACK;
        case 8: return DSS_CLT_SYNCAPPLYLOCALPORT_NACK;
        case 9: return CLT_DSS_ASYNCAPPLYLOCALPORT_REQ;
        case 10: return DSS_CLT_ASYNCAPPLYLOCALPORT_ACK;
        case 11: return DSS_CLT_ASYNCAPPLYLOCALPORT_NACK;
        case 12: return CLT_DSS_SYNCAPPLYCARRIERPORT_REQ;
        case 13: return DSS_CLT_SYNCAPPLYCARRIERPORT_ACK;
        case 14: return DSS_CLT_SYNCAPPLYCARRIERPORT_NACK;
        case 15: return CLT_DSS_ASYNCAPPLYCARRIERPORT_REQ;
        case 16: return DSS_CLT_ASYNCAPPLYCARRIERPORT_ACK;
        case 17: return DSS_CLT_ASYNCAPPLYCARRIERPORT_NACK;
        case 18: return CLT_DSS_RELEASEPORT_REQ;
        case 19: return DSS_CLT_RELEASEPORT_ACK;
        case 20: return DSS_CLT_RELEASEPORT_NACK;
        case 21: return CLT_DSS_ADDSWITCH_REQ;
        case 22: return DSS_CLT_ADDSWITCH_ACK;
        case 23: return DSS_CLT_ADDSWITCH_NACK;
        case 24: return CLT_DSS_REMOVESWITCH_REQ;
        case 25: return DSS_CLT_REMOVESWITCH_ACK;
        case 26: return DSS_CLT_REMOVESWITCH_NACK;
        case 27: return CLT_DSS_ADDM2ONESWITCH_REQ;
        case 28: return DSS_CLT_ADDM2ONESWITCH_ACK;
        case 29: return DSS_CLT_ADDM2ONESWITCH_NACK;
        case 30: return CLT_DSS_REMOVEM2ONESWITCH_REQ;
        case 31: return DSS_CLT_REMOVEM2ONESWITCH_ACK;
        case 32: return DSS_CLT_REMOVEM2ONESWITCH_NACK;
        case 33: return CLT_DSS_ADDDUMP_REQ;
        case 34: return DSS_CLT_ADDDUMP_ACK;
        case 35: return DSS_CLT_ADDDUMP_NACK;
        case 36: return CLT_DSS_REMOVEDUMP_REQ;
        case 37: return DSS_CLT_REMOVEDUMP_ACK;
        case 38: return DSS_CLT_REMOVEDUMP_NACK;
        case 39: return CLT_DSS_SYNCADDBRIDGE_REQ;
        case 40: return DSS_CLT_SYNCADDBRIDGE_ACK;
        case 41: return DSS_CLT_SYNCADDBRIDGE_NACK;
        case 42: return CLT_DSS_ASYNCADDBRIDGE_REQ;
        case 43: return DSS_CLT_ASYNCADDBRIDGE_ACK;
        case 44: return DSS_CLT_ASYNCADDBRIDGE_NACK;
        case 45: return CLT_DSS_REMOVEBRIDGE_REQ;
        case 46: return DSS_CLT_REMOVEBRIDGE_ACK;
        case 47: return DSS_CLT_REMOVEBRIDGE_NACK;
        case 48: return CLT_DSS_SENDTOBRIDGE_REQ;
        case 49: return DSS_CLT_SENDTOBRIDGE_ACK;
        case 50: return DSS_CLT_SENDTOBRIDGE_NACK;
        case 51: return CLT_DSS_STOPSENDTOBRIDGE_REQ;
        case 52: return DSS_CLT_STOPSENDTOBRIDGE_ACK;
        case 53: return DSS_CLT_STOPSENDTOBRIDGE_NACK;
        case 54: return CLT_DSS_RECEIVEFROMBRIDGE_REQ;
        case 55: return DSS_CLT_RECEIVEFROMBRIDGE_ACK;
        case 56: return DSS_CLT_RECEIVEFROMBRIDGE_NACK;
        case 57: return CLT_DSS_STOPRECEIVEFROMBRIDGE_REQ;
        case 58: return DSS_CLT_STOPRECEIVEFROMBRIDGE_ACK;
        case 59: return DSS_CLT_STOPRECEIVEFROMBRIDGE_NACK;
        case 60: return DSS_CLT_SRVLOST_NTF;
        case 61: return DSS_CLT_PING;
        case 62: return CLT_DSS_PONG;
        case 63: return CLT_DSS_ALIVEDETECT_REQ;
        case 64: return DSS_CLT_ALIVEDETECT_RSP;
        case 65: return DSS_CLT_SRVREGISTER_NTF;
        case 66: return CLT_DSS_CONNECTMASTER_REQ;
        case 67: return DSS_CLT_CONNECTMASTER_ACK;
        case 68: return DSS_CLT_CONNECTMASTER_NACK;
        case 69: return DSS_CLT_PONG;
        case 70: return CLT_DSS_PING;
        case 71: return CLT_DSS_GETLOSTRATEBYPORT_REQ;
        case 72: return DSS_CLT_GETLOSTRATEBYPORT_REPLY;
        case 73: return CLT_DSS_BINDWORKERTOMEETING_REQ;
        case 74: return DSS_CLT_BINDWORKERTOMEETING_ACK;
        case 75: return DSS_CLT_BINDWORKERTOMEETING_NACK;
        case 76: return CLT_DSS_UNBINDWORKERFROMMEETING_REQ;
        case 78: return DSS_CLT_UNBINDWORKERFROMMEETING_ACK;
        case 79: return DSS_CLT_UNBINDWORKERFROMMEETING_NACK;
        case 80: return DSS_CLT_REMOVECLIENT_NTF;
        case 81: return CLT_DSS_SYNCAPPLYPORT_REQ;
        case 82: return DSS_CLT_SYNCAPPLYPORT_ACK;
        case 83: return DSS_CLT_SYNCAPPLYPORT_NACK;
        case 84: return CLT_DSS_ASYNCAPPLYPORT_REQ;
        case 85: return DSS_CLT_ASYNCAPPLYPORT_ACK;
        case 86: return DSS_CLT_ASYNCAPPLYPORT_NACK;
        case 87: return DSS_CLT_BRIDGESPEAKERREMOVED_NTF;
        case 88: return CLT_DSS_DESTROYCLIENTBYUUID_REQ;
        case 89: return DSS_CLT_DESTROYCLIENTBYUUID_ACK;
        case 90: return DSS_CLT_DESTROYCLIENTBYUUID_NACK;
        case 91: return CLT_DSS_RELEASEPORTBYUUID_REQ;
        case 92: return DSS_CLT_RELEASEPORTBYUUID_ACK;
        case 93: return DSS_CLT_RELEASEPORTBYUUID_NACK;
        case 94: return CLT_DSS_REMOVEBRIDGEBYUUID_REQ;
        case 95: return DSS_CLT_REMOVEBRIDGEBYUUID_ACK;
        case 96: return DSS_CLT_REMOVEBRIDGEBYUUID_NACK;
        case 97: return CLT_DSS_SRVLOST_NTFRSP;
        case 98: return CLT_DSS_SRVREGISTER_NTFRSP;
        case 99: return CLT_DSS_RELEASEPARTPORT_REQ;
        case 100: return DSS_CLT_RELEASEPARPORT_ACK;
        case 101: return DSS_CLT_RELEASEPARPORT_NACK;
        case 102: return DSS_CLT_DYNAMICENCRPTYKEYLENSS_NTF;
        case 103: return CLT_DSS_UPDATEDYNAMICENCRPTYKEY_CMD;
        case 104: return CLT_DSS_SET_EPMUTE_REQ;
        case 105: return DSS_CLT_SET_EPMUTE_ACK;
        case 106: return DSS_CLT_SET_EPMUTE_NACK;
        case 107: return CLT_DSS_SET_EPSILENT_REQ;
        case 108: return DSS_CLT_SET_EPSILENT_ACK;
        case 109: return DSS_CLT_SET_EPSILENT_NACK;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<CltDssEvent>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<CltDssEvent>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<CltDssEvent>() {
            public CltDssEvent findValueByNumber(int number) {
              return CltDssEvent.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(0);
    }

    private static final CltDssEvent[] VALUES = values();

    public static CltDssEvent valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private CltDssEvent(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.CltDssEvent)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.EIpType}
   */
  public enum EIpType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>IpTypeUnknown = 0;</code>
     */
    IpTypeUnknown(0, 0),
    /**
     * <code>eIpV4 = 1;</code>
     */
    eIpV4(1, 1),
    /**
     * <code>eIpV6 = 2;</code>
     */
    eIpV6(2, 2),
    ;

    /**
     * <code>IpTypeUnknown = 0;</code>
     */
    public static final int IpTypeUnknown_VALUE = 0;
    /**
     * <code>eIpV4 = 1;</code>
     */
    public static final int eIpV4_VALUE = 1;
    /**
     * <code>eIpV6 = 2;</code>
     */
    public static final int eIpV6_VALUE = 2;


    public final int getNumber() { return value; }

    public static EIpType valueOf(int value) {
      switch (value) {
        case 0: return IpTypeUnknown;
        case 1: return eIpV4;
        case 2: return eIpV6;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EIpType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EIpType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EIpType>() {
            public EIpType findValueByNumber(int number) {
              return EIpType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(1);
    }

    private static final EIpType[] VALUES = values();

    public static EIpType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EIpType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.EIpType)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.EClientType}
   */
  public enum EClientType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>DssObjUnknown = 0;</code>
     */
    DssObjUnknown(0, 0),
    /**
     * <code>DSS_CONF = 1;</code>
     */
    DSS_CONF(1, 1),
    /**
     * <code>DSS_NU = 2;</code>
     */
    DSS_NU(2, 2),
    /**
     * <code>DSS_PSEUDOCLIENT = 3;</code>
     */
    DSS_PSEUDOCLIENT(3, 3),
    ;

    /**
     * <code>DssObjUnknown = 0;</code>
     */
    public static final int DssObjUnknown_VALUE = 0;
    /**
     * <code>DSS_CONF = 1;</code>
     */
    public static final int DSS_CONF_VALUE = 1;
    /**
     * <code>DSS_NU = 2;</code>
     */
    public static final int DSS_NU_VALUE = 2;
    /**
     * <code>DSS_PSEUDOCLIENT = 3;</code>
     */
    public static final int DSS_PSEUDOCLIENT_VALUE = 3;


    public final int getNumber() { return value; }

    public static EClientType valueOf(int value) {
      switch (value) {
        case 0: return DssObjUnknown;
        case 1: return DSS_CONF;
        case 2: return DSS_NU;
        case 3: return DSS_PSEUDOCLIENT;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EClientType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EClientType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EClientType>() {
            public EClientType findValueByNumber(int number) {
              return EClientType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(2);
    }

    private static final EClientType[] VALUES = values();

    public static EClientType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EClientType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.EClientType)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.ESwitchType}
   */
  public enum ESwitchType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>DsTypeUnknown = 0;</code>
     */
    DsTypeUnknown(0, 0),
    /**
     * <code>DSRTP = 1;</code>
     */
    DSRTP(1, 1),
    /**
     * <code>DSRTCP = 2;</code>
     */
    DSRTCP(2, 2),
    /**
     * <code>DSDUMP = 3;</code>
     */
    DSDUMP(3, 3),
    ;

    /**
     * <code>DsTypeUnknown = 0;</code>
     */
    public static final int DsTypeUnknown_VALUE = 0;
    /**
     * <code>DSRTP = 1;</code>
     */
    public static final int DSRTP_VALUE = 1;
    /**
     * <code>DSRTCP = 2;</code>
     */
    public static final int DSRTCP_VALUE = 2;
    /**
     * <code>DSDUMP = 3;</code>
     */
    public static final int DSDUMP_VALUE = 3;


    public final int getNumber() { return value; }

    public static ESwitchType valueOf(int value) {
      switch (value) {
        case 0: return DsTypeUnknown;
        case 1: return DSRTP;
        case 2: return DSRTCP;
        case 3: return DSDUMP;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ESwitchType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<ESwitchType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ESwitchType>() {
            public ESwitchType findValueByNumber(int number) {
              return ESwitchType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(3);
    }

    private static final ESwitchType[] VALUES = values();

    public static ESwitchType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private ESwitchType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.ESwitchType)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.ESwitchStreamType}
   */
  public enum ESwitchStreamType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>StreamType_Unknown = 0;</code>
     */
    StreamType_Unknown(0, 0),
    /**
     * <code>SwitchStreamType_AUDIO = 1;</code>
     */
    SwitchStreamType_AUDIO(1, 1),
    /**
     * <code>SwitchStreamType_VIDEO = 2;</code>
     */
    SwitchStreamType_VIDEO(2, 2),
    /**
     * <code>SwitchStreamType_224DATA = 3;</code>
     */
    SwitchStreamType_224DATA(3, 3),
    ;

    /**
     * <code>StreamType_Unknown = 0;</code>
     */
    public static final int StreamType_Unknown_VALUE = 0;
    /**
     * <code>SwitchStreamType_AUDIO = 1;</code>
     */
    public static final int SwitchStreamType_AUDIO_VALUE = 1;
    /**
     * <code>SwitchStreamType_VIDEO = 2;</code>
     */
    public static final int SwitchStreamType_VIDEO_VALUE = 2;
    /**
     * <code>SwitchStreamType_224DATA = 3;</code>
     */
    public static final int SwitchStreamType_224DATA_VALUE = 3;


    public final int getNumber() { return value; }

    public static ESwitchStreamType valueOf(int value) {
      switch (value) {
        case 0: return StreamType_Unknown;
        case 1: return SwitchStreamType_AUDIO;
        case 2: return SwitchStreamType_VIDEO;
        case 3: return SwitchStreamType_224DATA;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ESwitchStreamType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<ESwitchStreamType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ESwitchStreamType>() {
            public ESwitchStreamType findValueByNumber(int number) {
              return ESwitchStreamType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(4);
    }

    private static final ESwitchStreamType[] VALUES = values();

    public static ESwitchStreamType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private ESwitchStreamType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.ESwitchStreamType)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.ESwitchDirectionType}
   */
  public enum ESwitchDirectionType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>DSDIRECTION_NONE = 0;</code>
     */
    DSDIRECTION_NONE(0, 0),
    /**
     * <code>DSDIRECTION_DOWN_SWITCH = 1;</code>
     */
    DSDIRECTION_DOWN_SWITCH(1, 1),
    /**
     * <code>DSDIRECTION_UP_SWITCH = 2;</code>
     */
    DSDIRECTION_UP_SWITCH(2, 2),
    ;

    /**
     * <code>DSDIRECTION_NONE = 0;</code>
     */
    public static final int DSDIRECTION_NONE_VALUE = 0;
    /**
     * <code>DSDIRECTION_DOWN_SWITCH = 1;</code>
     */
    public static final int DSDIRECTION_DOWN_SWITCH_VALUE = 1;
    /**
     * <code>DSDIRECTION_UP_SWITCH = 2;</code>
     */
    public static final int DSDIRECTION_UP_SWITCH_VALUE = 2;


    public final int getNumber() { return value; }

    public static ESwitchDirectionType valueOf(int value) {
      switch (value) {
        case 0: return DSDIRECTION_NONE;
        case 1: return DSDIRECTION_DOWN_SWITCH;
        case 2: return DSDIRECTION_UP_SWITCH;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ESwitchDirectionType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<ESwitchDirectionType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ESwitchDirectionType>() {
            public ESwitchDirectionType findValueByNumber(int number) {
              return ESwitchDirectionType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(5);
    }

    private static final ESwitchDirectionType[] VALUES = values();

    public static ESwitchDirectionType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private ESwitchDirectionType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.ESwitchDirectionType)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.ESecMode}
   *
   * <pre>
   *加密模式
   * </pre>
   */
  public enum ESecMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>SEC_MODE_NONE = 0;</code>
     */
    SEC_MODE_NONE(0, 0),
    /**
     * <code>SEC_MODE_ECB = 1;</code>
     */
    SEC_MODE_ECB(1, 1),
    /**
     * <code>SEC_MODE_CBC = 2;</code>
     */
    SEC_MODE_CBC(2, 2),
    /**
     * <code>SEC_MODE_CFB = 3;</code>
     */
    SEC_MODE_CFB(3, 3),
    /**
     * <code>SEC_MODE_OFB = 4;</code>
     */
    SEC_MODE_OFB(4, 4),
    /**
     * <code>SEC_MODE_MAC = 5;</code>
     */
    SEC_MODE_MAC(5, 5),
    /**
     * <code>SEC_MODE_CTR = 6;</code>
     */
    SEC_MODE_CTR(6, 6),
    ;

    /**
     * <code>SEC_MODE_NONE = 0;</code>
     */
    public static final int SEC_MODE_NONE_VALUE = 0;
    /**
     * <code>SEC_MODE_ECB = 1;</code>
     */
    public static final int SEC_MODE_ECB_VALUE = 1;
    /**
     * <code>SEC_MODE_CBC = 2;</code>
     */
    public static final int SEC_MODE_CBC_VALUE = 2;
    /**
     * <code>SEC_MODE_CFB = 3;</code>
     */
    public static final int SEC_MODE_CFB_VALUE = 3;
    /**
     * <code>SEC_MODE_OFB = 4;</code>
     */
    public static final int SEC_MODE_OFB_VALUE = 4;
    /**
     * <code>SEC_MODE_MAC = 5;</code>
     */
    public static final int SEC_MODE_MAC_VALUE = 5;
    /**
     * <code>SEC_MODE_CTR = 6;</code>
     */
    public static final int SEC_MODE_CTR_VALUE = 6;


    public final int getNumber() { return value; }

    public static ESecMode valueOf(int value) {
      switch (value) {
        case 0: return SEC_MODE_NONE;
        case 1: return SEC_MODE_ECB;
        case 2: return SEC_MODE_CBC;
        case 3: return SEC_MODE_CFB;
        case 4: return SEC_MODE_OFB;
        case 5: return SEC_MODE_MAC;
        case 6: return SEC_MODE_CTR;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ESecMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<ESecMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ESecMode>() {
            public ESecMode findValueByNumber(int number) {
              return ESecMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(6);
    }

    private static final ESecMode[] VALUES = values();

    public static ESecMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private ESecMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.ESecMode)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.ESecAlg}
   */
  public enum ESecAlg
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>SEC_ALG_NONE = 0;</code>
     */
    SEC_ALG_NONE(0, 0),
    /**
     * <code>SEC_ALG_SM1 = 1;</code>
     *
     * <pre>
     *对称算法
     * </pre>
     */
    SEC_ALG_SM1(1, 1),
    /**
     * <code>SEC_ALG_SSF33 = 2;</code>
     */
    SEC_ALG_SSF33(2, 2),
    /**
     * <code>SEC_ALG_SM4 = 3;</code>
     */
    SEC_ALG_SM4(3, 3),
    /**
     * <code>SEC_ALG_DES = 4;</code>
     */
    SEC_ALG_DES(4, 4),
    /**
     * <code>SEC_ALG_AES = 5;</code>
     */
    SEC_ALG_AES(5, 5),
    /**
     * <code>SEC_ALG_3DES = 6;</code>
     */
    SEC_ALG_3DES(6, 6),
    /**
     * <code>SEC_ALG_RSA = 7;</code>
     *
     * <pre>
     *非对称算法
     * </pre>
     */
    SEC_ALG_RSA(7, 7),
    /**
     * <code>SEC_ALG_SM2_1 = 8;</code>
     */
    SEC_ALG_SM2_1(8, 8),
    /**
     * <code>SEC_ALG_SM2_2 = 9;</code>
     */
    SEC_ALG_SM2_2(9, 9),
    /**
     * <code>SEC_ALG_SM2_3 = 10;</code>
     */
    SEC_ALG_SM2_3(10, 10),
    /**
     * <code>SEC_ALG_SM3 = 11;</code>
     *
     * <pre>
     *散列算法
     * </pre>
     */
    SEC_ALG_SM3(11, 11),
    /**
     * <code>SEC_ALG_SHA1 = 12;</code>
     */
    SEC_ALG_SHA1(12, 12),
    /**
     * <code>SEC_ALG_SHA256 = 13;</code>
     */
    SEC_ALG_SHA256(13, 13),
    ;

    /**
     * <code>SEC_ALG_NONE = 0;</code>
     */
    public static final int SEC_ALG_NONE_VALUE = 0;
    /**
     * <code>SEC_ALG_SM1 = 1;</code>
     *
     * <pre>
     *对称算法
     * </pre>
     */
    public static final int SEC_ALG_SM1_VALUE = 1;
    /**
     * <code>SEC_ALG_SSF33 = 2;</code>
     */
    public static final int SEC_ALG_SSF33_VALUE = 2;
    /**
     * <code>SEC_ALG_SM4 = 3;</code>
     */
    public static final int SEC_ALG_SM4_VALUE = 3;
    /**
     * <code>SEC_ALG_DES = 4;</code>
     */
    public static final int SEC_ALG_DES_VALUE = 4;
    /**
     * <code>SEC_ALG_AES = 5;</code>
     */
    public static final int SEC_ALG_AES_VALUE = 5;
    /**
     * <code>SEC_ALG_3DES = 6;</code>
     */
    public static final int SEC_ALG_3DES_VALUE = 6;
    /**
     * <code>SEC_ALG_RSA = 7;</code>
     *
     * <pre>
     *非对称算法
     * </pre>
     */
    public static final int SEC_ALG_RSA_VALUE = 7;
    /**
     * <code>SEC_ALG_SM2_1 = 8;</code>
     */
    public static final int SEC_ALG_SM2_1_VALUE = 8;
    /**
     * <code>SEC_ALG_SM2_2 = 9;</code>
     */
    public static final int SEC_ALG_SM2_2_VALUE = 9;
    /**
     * <code>SEC_ALG_SM2_3 = 10;</code>
     */
    public static final int SEC_ALG_SM2_3_VALUE = 10;
    /**
     * <code>SEC_ALG_SM3 = 11;</code>
     *
     * <pre>
     *散列算法
     * </pre>
     */
    public static final int SEC_ALG_SM3_VALUE = 11;
    /**
     * <code>SEC_ALG_SHA1 = 12;</code>
     */
    public static final int SEC_ALG_SHA1_VALUE = 12;
    /**
     * <code>SEC_ALG_SHA256 = 13;</code>
     */
    public static final int SEC_ALG_SHA256_VALUE = 13;


    public final int getNumber() { return value; }

    public static ESecAlg valueOf(int value) {
      switch (value) {
        case 0: return SEC_ALG_NONE;
        case 1: return SEC_ALG_SM1;
        case 2: return SEC_ALG_SSF33;
        case 3: return SEC_ALG_SM4;
        case 4: return SEC_ALG_DES;
        case 5: return SEC_ALG_AES;
        case 6: return SEC_ALG_3DES;
        case 7: return SEC_ALG_RSA;
        case 8: return SEC_ALG_SM2_1;
        case 9: return SEC_ALG_SM2_2;
        case 10: return SEC_ALG_SM2_3;
        case 11: return SEC_ALG_SM3;
        case 12: return SEC_ALG_SHA1;
        case 13: return SEC_ALG_SHA256;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ESecAlg>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<ESecAlg>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ESecAlg>() {
            public ESecAlg findValueByNumber(int number) {
              return ESecAlg.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(7);
    }

    private static final ESecAlg[] VALUES = values();

    public static ESecAlg valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private ESecAlg(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.ESecAlg)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.EDssInitResultCode}
   */
  public enum EDssInitResultCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>eInitSucceed = 0;</code>
     */
    eInitSucceed(0, 0),
    ;

    /**
     * <code>eInitSucceed = 0;</code>
     */
    public static final int eInitSucceed_VALUE = 0;


    public final int getNumber() { return value; }

    public static EDssInitResultCode valueOf(int value) {
      switch (value) {
        case 0: return eInitSucceed;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EDssInitResultCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EDssInitResultCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EDssInitResultCode>() {
            public EDssInitResultCode findValueByNumber(int number) {
              return EDssInitResultCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(8);
    }

    private static final EDssInitResultCode[] VALUES = values();

    public static EDssInitResultCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EDssInitResultCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.EDssInitResultCode)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.EDssCarrierReqResultCode}
   */
  public enum EDssCarrierReqResultCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>eCarrierSucceed = 0;</code>
     */
    eCarrierSucceed(0, 0),
    /**
     * <code>eCarrierInvalidParam = 1;</code>
     */
    eCarrierInvalidParam(1, 1),
    /**
     * <code>eCarrierClientNotFound = 2;</code>
     */
    eCarrierClientNotFound(2, 2),
    /**
     * <code>eCarrierTimeOut = 3;</code>
     */
    eCarrierTimeOut(3, 3),
    /**
     * <code>eCarrierUnknownFail = 4;</code>
     */
    eCarrierUnknownFail(4, 4),
    /**
     * <code>eCarrierAsyncSucceed = 5;</code>
     */
    eCarrierAsyncSucceed(5, 5),
    /**
     * <code>eCarrierPortnumNotEnough = 6;</code>
     */
    eCarrierPortnumNotEnough(6, 6),
    /**
     * <code>eCarrierBandwidthNotEnough = 7;</code>
     */
    eCarrierBandwidthNotEnough(7, 7),
    /**
     * <code>eCarrierSpecifiedCarrierNotExist = 8;</code>
     */
    eCarrierSpecifiedCarrierNotExist(8, 8),
    /**
     * <code>eCarrierSpecifiedCarrierDmzNotExist = 9;</code>
     */
    eCarrierSpecifiedCarrierDmzNotExist(9, 9),
    /**
     * <code>eCarrierConsPortnumNotEnough = 10;</code>
     */
    eCarrierConsPortnumNotEnough(10, 10),
    /**
     * <code>eCarrierInvalidClient = 11;</code>
     */
    eCarrierInvalidClient(11, 11),
    /**
     * <code>eCarrierSpecifiedWorkerNotFound = 12;</code>
     */
    eCarrierSpecifiedWorkerNotFound(12, 12),
    /**
     * <code>eCarrierNoAvailableWorker = 13;</code>
     */
    eCarrierNoAvailableWorker(13, 13),
    /**
     * <code>eCarrierWorkerResourceExhausted = 14;</code>
     */
    eCarrierWorkerResourceExhausted(14, 14),
    /**
     * <code>eCarrierPortHandleExhausted = 15;</code>
     */
    eCarrierPortHandleExhausted(15, 15),
    ;

    /**
     * <code>eCarrierSucceed = 0;</code>
     */
    public static final int eCarrierSucceed_VALUE = 0;
    /**
     * <code>eCarrierInvalidParam = 1;</code>
     */
    public static final int eCarrierInvalidParam_VALUE = 1;
    /**
     * <code>eCarrierClientNotFound = 2;</code>
     */
    public static final int eCarrierClientNotFound_VALUE = 2;
    /**
     * <code>eCarrierTimeOut = 3;</code>
     */
    public static final int eCarrierTimeOut_VALUE = 3;
    /**
     * <code>eCarrierUnknownFail = 4;</code>
     */
    public static final int eCarrierUnknownFail_VALUE = 4;
    /**
     * <code>eCarrierAsyncSucceed = 5;</code>
     */
    public static final int eCarrierAsyncSucceed_VALUE = 5;
    /**
     * <code>eCarrierPortnumNotEnough = 6;</code>
     */
    public static final int eCarrierPortnumNotEnough_VALUE = 6;
    /**
     * <code>eCarrierBandwidthNotEnough = 7;</code>
     */
    public static final int eCarrierBandwidthNotEnough_VALUE = 7;
    /**
     * <code>eCarrierSpecifiedCarrierNotExist = 8;</code>
     */
    public static final int eCarrierSpecifiedCarrierNotExist_VALUE = 8;
    /**
     * <code>eCarrierSpecifiedCarrierDmzNotExist = 9;</code>
     */
    public static final int eCarrierSpecifiedCarrierDmzNotExist_VALUE = 9;
    /**
     * <code>eCarrierConsPortnumNotEnough = 10;</code>
     */
    public static final int eCarrierConsPortnumNotEnough_VALUE = 10;
    /**
     * <code>eCarrierInvalidClient = 11;</code>
     */
    public static final int eCarrierInvalidClient_VALUE = 11;
    /**
     * <code>eCarrierSpecifiedWorkerNotFound = 12;</code>
     */
    public static final int eCarrierSpecifiedWorkerNotFound_VALUE = 12;
    /**
     * <code>eCarrierNoAvailableWorker = 13;</code>
     */
    public static final int eCarrierNoAvailableWorker_VALUE = 13;
    /**
     * <code>eCarrierWorkerResourceExhausted = 14;</code>
     */
    public static final int eCarrierWorkerResourceExhausted_VALUE = 14;
    /**
     * <code>eCarrierPortHandleExhausted = 15;</code>
     */
    public static final int eCarrierPortHandleExhausted_VALUE = 15;


    public final int getNumber() { return value; }

    public static EDssCarrierReqResultCode valueOf(int value) {
      switch (value) {
        case 0: return eCarrierSucceed;
        case 1: return eCarrierInvalidParam;
        case 2: return eCarrierClientNotFound;
        case 3: return eCarrierTimeOut;
        case 4: return eCarrierUnknownFail;
        case 5: return eCarrierAsyncSucceed;
        case 6: return eCarrierPortnumNotEnough;
        case 7: return eCarrierBandwidthNotEnough;
        case 8: return eCarrierSpecifiedCarrierNotExist;
        case 9: return eCarrierSpecifiedCarrierDmzNotExist;
        case 10: return eCarrierConsPortnumNotEnough;
        case 11: return eCarrierInvalidClient;
        case 12: return eCarrierSpecifiedWorkerNotFound;
        case 13: return eCarrierNoAvailableWorker;
        case 14: return eCarrierWorkerResourceExhausted;
        case 15: return eCarrierPortHandleExhausted;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EDssCarrierReqResultCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EDssCarrierReqResultCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EDssCarrierReqResultCode>() {
            public EDssCarrierReqResultCode findValueByNumber(int number) {
              return EDssCarrierReqResultCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(9);
    }

    private static final EDssCarrierReqResultCode[] VALUES = values();

    public static EDssCarrierReqResultCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EDssCarrierReqResultCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.EDssCarrierReqResultCode)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.EDssLocalReqResultCode}
   */
  public enum EDssLocalReqResultCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>eLocalSucceed = 0;</code>
     */
    eLocalSucceed(0, 0),
    /**
     * <code>eLocalInvalidParam = 1;</code>
     */
    eLocalInvalidParam(1, 1),
    /**
     * <code>eLocalClientNotFound = 2;</code>
     */
    eLocalClientNotFound(2, 2),
    /**
     * <code>eLocalTimeOut = 3;</code>
     */
    eLocalTimeOut(3, 3),
    /**
     * <code>eLocalUnknownFail = 4;</code>
     */
    eLocalUnknownFail(4, 4),
    /**
     * <code>eLocalAsyncSucceed = 5;</code>
     */
    eLocalAsyncSucceed(5, 5),
    /**
     * <code>eLocalPortnumNotEnough = 6;</code>
     */
    eLocalPortnumNotEnough(6, 6),
    /**
     * <code>eLocalBandwidthNotEnough = 7;</code>
     */
    eLocalBandwidthNotEnough(7, 7),
    /**
     * <code>eLocalNoLocalAddr = 8;</code>
     */
    eLocalNoLocalAddr(8, 8),
    /**
     * <code>eLocalConsPortnumNotEnough = 9;</code>
     */
    eLocalConsPortnumNotEnough(9, 9),
    /**
     * <code>eLocalInvalidClient = 10;</code>
     */
    eLocalInvalidClient(10, 10),
    /**
     * <code>eLocalSpecifiedCarrierNotExist = 11;</code>
     */
    eLocalSpecifiedCarrierNotExist(11, 11),
    /**
     * <code>eLocalSpecifiedCarrierDmzNotExist = 12;</code>
     */
    eLocalSpecifiedCarrierDmzNotExist(12, 12),
    /**
     * <code>eLocalNoWorkerRegistered = 13;</code>
     */
    eLocalNoWorkerRegistered(13, 13),
    /**
     * <code>eLocalSpecifiedWorkerNotFound = 14;</code>
     */
    eLocalSpecifiedWorkerNotFound(14, 14),
    /**
     * <code>eLocalNoAvailableWorker = 15;</code>
     */
    eLocalNoAvailableWorker(15, 15),
    /**
     * <code>eLocalWorkerResourceExhausted = 16;</code>
     */
    eLocalWorkerResourceExhausted(16, 16),
    /**
     * <code>eLocalPortHandleExhausted = 17;</code>
     */
    eLocalPortHandleExhausted(17, 17),
    ;

    /**
     * <code>eLocalSucceed = 0;</code>
     */
    public static final int eLocalSucceed_VALUE = 0;
    /**
     * <code>eLocalInvalidParam = 1;</code>
     */
    public static final int eLocalInvalidParam_VALUE = 1;
    /**
     * <code>eLocalClientNotFound = 2;</code>
     */
    public static final int eLocalClientNotFound_VALUE = 2;
    /**
     * <code>eLocalTimeOut = 3;</code>
     */
    public static final int eLocalTimeOut_VALUE = 3;
    /**
     * <code>eLocalUnknownFail = 4;</code>
     */
    public static final int eLocalUnknownFail_VALUE = 4;
    /**
     * <code>eLocalAsyncSucceed = 5;</code>
     */
    public static final int eLocalAsyncSucceed_VALUE = 5;
    /**
     * <code>eLocalPortnumNotEnough = 6;</code>
     */
    public static final int eLocalPortnumNotEnough_VALUE = 6;
    /**
     * <code>eLocalBandwidthNotEnough = 7;</code>
     */
    public static final int eLocalBandwidthNotEnough_VALUE = 7;
    /**
     * <code>eLocalNoLocalAddr = 8;</code>
     */
    public static final int eLocalNoLocalAddr_VALUE = 8;
    /**
     * <code>eLocalConsPortnumNotEnough = 9;</code>
     */
    public static final int eLocalConsPortnumNotEnough_VALUE = 9;
    /**
     * <code>eLocalInvalidClient = 10;</code>
     */
    public static final int eLocalInvalidClient_VALUE = 10;
    /**
     * <code>eLocalSpecifiedCarrierNotExist = 11;</code>
     */
    public static final int eLocalSpecifiedCarrierNotExist_VALUE = 11;
    /**
     * <code>eLocalSpecifiedCarrierDmzNotExist = 12;</code>
     */
    public static final int eLocalSpecifiedCarrierDmzNotExist_VALUE = 12;
    /**
     * <code>eLocalNoWorkerRegistered = 13;</code>
     */
    public static final int eLocalNoWorkerRegistered_VALUE = 13;
    /**
     * <code>eLocalSpecifiedWorkerNotFound = 14;</code>
     */
    public static final int eLocalSpecifiedWorkerNotFound_VALUE = 14;
    /**
     * <code>eLocalNoAvailableWorker = 15;</code>
     */
    public static final int eLocalNoAvailableWorker_VALUE = 15;
    /**
     * <code>eLocalWorkerResourceExhausted = 16;</code>
     */
    public static final int eLocalWorkerResourceExhausted_VALUE = 16;
    /**
     * <code>eLocalPortHandleExhausted = 17;</code>
     */
    public static final int eLocalPortHandleExhausted_VALUE = 17;


    public final int getNumber() { return value; }

    public static EDssLocalReqResultCode valueOf(int value) {
      switch (value) {
        case 0: return eLocalSucceed;
        case 1: return eLocalInvalidParam;
        case 2: return eLocalClientNotFound;
        case 3: return eLocalTimeOut;
        case 4: return eLocalUnknownFail;
        case 5: return eLocalAsyncSucceed;
        case 6: return eLocalPortnumNotEnough;
        case 7: return eLocalBandwidthNotEnough;
        case 8: return eLocalNoLocalAddr;
        case 9: return eLocalConsPortnumNotEnough;
        case 10: return eLocalInvalidClient;
        case 11: return eLocalSpecifiedCarrierNotExist;
        case 12: return eLocalSpecifiedCarrierDmzNotExist;
        case 13: return eLocalNoWorkerRegistered;
        case 14: return eLocalSpecifiedWorkerNotFound;
        case 15: return eLocalNoAvailableWorker;
        case 16: return eLocalWorkerResourceExhausted;
        case 17: return eLocalPortHandleExhausted;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EDssLocalReqResultCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EDssLocalReqResultCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EDssLocalReqResultCode>() {
            public EDssLocalReqResultCode findValueByNumber(int number) {
              return EDssLocalReqResultCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(10);
    }

    private static final EDssLocalReqResultCode[] VALUES = values();

    public static EDssLocalReqResultCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EDssLocalReqResultCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.EDssLocalReqResultCode)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.EDssApplyPortResultCode}
   */
  public enum EDssApplyPortResultCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>eApplyPortSucceed = 0;</code>
     */
    eApplyPortSucceed(0, 0),
    /**
     * <code>eApplyPortInvalidParam = 1;</code>
     */
    eApplyPortInvalidParam(1, 1),
    /**
     * <code>eApplyPortClientNotFound = 2;</code>
     */
    eApplyPortClientNotFound(2, 2),
    /**
     * <code>eApplyPortTimeOut = 3;</code>
     */
    eApplyPortTimeOut(3, 3),
    /**
     * <code>eApplyPortUnknownFail = 4;</code>
     */
    eApplyPortUnknownFail(4, 4),
    /**
     * <code>eApplyPortAsyncSucceed = 5;</code>
     */
    eApplyPortAsyncSucceed(5, 5),
    /**
     * <code>eApplyPortPortnumNotEnough = 6;</code>
     */
    eApplyPortPortnumNotEnough(6, 6),
    /**
     * <code>eApplyPortBandwidthNotEnough = 7;</code>
     */
    eApplyPortBandwidthNotEnough(7, 7),
    /**
     * <code>eApplyPortSpecifiedCarrierNotExist = 8;</code>
     */
    eApplyPortSpecifiedCarrierNotExist(8, 8),
    /**
     * <code>eApplyPortSpecifiedCarrierDmzNotExist = 9;</code>
     */
    eApplyPortSpecifiedCarrierDmzNotExist(9, 9),
    /**
     * <code>eApplyPortConsPortnumNotEnough = 10;</code>
     */
    eApplyPortConsPortnumNotEnough(10, 10),
    /**
     * <code>eApplyPortInvalidClient = 11;</code>
     */
    eApplyPortInvalidClient(11, 11),
    /**
     * <code>eApplyPortSpecifiedWorkerNotFound = 12;</code>
     */
    eApplyPortSpecifiedWorkerNotFound(12, 12),
    /**
     * <code>eApplyPortNoAvailableWorker = 13;</code>
     */
    eApplyPortNoAvailableWorker(13, 13),
    /**
     * <code>eApplyPortWorkerResourceExhausted = 14;</code>
     */
    eApplyPortWorkerResourceExhausted(14, 14),
    /**
     * <code>eApplyPortPortHandleExhausted = 15;</code>
     */
    eApplyPortPortHandleExhausted(15, 15),
    ;

    /**
     * <code>eApplyPortSucceed = 0;</code>
     */
    public static final int eApplyPortSucceed_VALUE = 0;
    /**
     * <code>eApplyPortInvalidParam = 1;</code>
     */
    public static final int eApplyPortInvalidParam_VALUE = 1;
    /**
     * <code>eApplyPortClientNotFound = 2;</code>
     */
    public static final int eApplyPortClientNotFound_VALUE = 2;
    /**
     * <code>eApplyPortTimeOut = 3;</code>
     */
    public static final int eApplyPortTimeOut_VALUE = 3;
    /**
     * <code>eApplyPortUnknownFail = 4;</code>
     */
    public static final int eApplyPortUnknownFail_VALUE = 4;
    /**
     * <code>eApplyPortAsyncSucceed = 5;</code>
     */
    public static final int eApplyPortAsyncSucceed_VALUE = 5;
    /**
     * <code>eApplyPortPortnumNotEnough = 6;</code>
     */
    public static final int eApplyPortPortnumNotEnough_VALUE = 6;
    /**
     * <code>eApplyPortBandwidthNotEnough = 7;</code>
     */
    public static final int eApplyPortBandwidthNotEnough_VALUE = 7;
    /**
     * <code>eApplyPortSpecifiedCarrierNotExist = 8;</code>
     */
    public static final int eApplyPortSpecifiedCarrierNotExist_VALUE = 8;
    /**
     * <code>eApplyPortSpecifiedCarrierDmzNotExist = 9;</code>
     */
    public static final int eApplyPortSpecifiedCarrierDmzNotExist_VALUE = 9;
    /**
     * <code>eApplyPortConsPortnumNotEnough = 10;</code>
     */
    public static final int eApplyPortConsPortnumNotEnough_VALUE = 10;
    /**
     * <code>eApplyPortInvalidClient = 11;</code>
     */
    public static final int eApplyPortInvalidClient_VALUE = 11;
    /**
     * <code>eApplyPortSpecifiedWorkerNotFound = 12;</code>
     */
    public static final int eApplyPortSpecifiedWorkerNotFound_VALUE = 12;
    /**
     * <code>eApplyPortNoAvailableWorker = 13;</code>
     */
    public static final int eApplyPortNoAvailableWorker_VALUE = 13;
    /**
     * <code>eApplyPortWorkerResourceExhausted = 14;</code>
     */
    public static final int eApplyPortWorkerResourceExhausted_VALUE = 14;
    /**
     * <code>eApplyPortPortHandleExhausted = 15;</code>
     */
    public static final int eApplyPortPortHandleExhausted_VALUE = 15;


    public final int getNumber() { return value; }

    public static EDssApplyPortResultCode valueOf(int value) {
      switch (value) {
        case 0: return eApplyPortSucceed;
        case 1: return eApplyPortInvalidParam;
        case 2: return eApplyPortClientNotFound;
        case 3: return eApplyPortTimeOut;
        case 4: return eApplyPortUnknownFail;
        case 5: return eApplyPortAsyncSucceed;
        case 6: return eApplyPortPortnumNotEnough;
        case 7: return eApplyPortBandwidthNotEnough;
        case 8: return eApplyPortSpecifiedCarrierNotExist;
        case 9: return eApplyPortSpecifiedCarrierDmzNotExist;
        case 10: return eApplyPortConsPortnumNotEnough;
        case 11: return eApplyPortInvalidClient;
        case 12: return eApplyPortSpecifiedWorkerNotFound;
        case 13: return eApplyPortNoAvailableWorker;
        case 14: return eApplyPortWorkerResourceExhausted;
        case 15: return eApplyPortPortHandleExhausted;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EDssApplyPortResultCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EDssApplyPortResultCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EDssApplyPortResultCode>() {
            public EDssApplyPortResultCode findValueByNumber(int number) {
              return EDssApplyPortResultCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(11);
    }

    private static final EDssApplyPortResultCode[] VALUES = values();

    public static EDssApplyPortResultCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EDssApplyPortResultCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.EDssApplyPortResultCode)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.EDssAddBridgeResultCode}
   */
  public enum EDssAddBridgeResultCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>eAddBridgeSucceed = 0;</code>
     */
    eAddBridgeSucceed(0, 0),
    /**
     * <code>eAddBridgeNoWorkerInMeeting = 1;</code>
     */
    eAddBridgeNoWorkerInMeeting(1, 1),
    /**
     * <code>eAddBridgePortNotEnough = 2;</code>
     */
    eAddBridgePortNotEnough(2, 2),
    /**
     * <code>eAddBridgeInvalidClient = 3;</code>
     */
    eAddBridgeInvalidClient(3, 3),
    /**
     * <code>eAddBridgeNewBridgeFail = 4;</code>
     */
    eAddBridgeNewBridgeFail(4, 4),
    /**
     * <code>eAddBridgeNewBridgeNodeFail = 5;</code>
     */
    eAddBridgeNewBridgeNodeFail(5, 5),
    ;

    /**
     * <code>eAddBridgeSucceed = 0;</code>
     */
    public static final int eAddBridgeSucceed_VALUE = 0;
    /**
     * <code>eAddBridgeNoWorkerInMeeting = 1;</code>
     */
    public static final int eAddBridgeNoWorkerInMeeting_VALUE = 1;
    /**
     * <code>eAddBridgePortNotEnough = 2;</code>
     */
    public static final int eAddBridgePortNotEnough_VALUE = 2;
    /**
     * <code>eAddBridgeInvalidClient = 3;</code>
     */
    public static final int eAddBridgeInvalidClient_VALUE = 3;
    /**
     * <code>eAddBridgeNewBridgeFail = 4;</code>
     */
    public static final int eAddBridgeNewBridgeFail_VALUE = 4;
    /**
     * <code>eAddBridgeNewBridgeNodeFail = 5;</code>
     */
    public static final int eAddBridgeNewBridgeNodeFail_VALUE = 5;


    public final int getNumber() { return value; }

    public static EDssAddBridgeResultCode valueOf(int value) {
      switch (value) {
        case 0: return eAddBridgeSucceed;
        case 1: return eAddBridgeNoWorkerInMeeting;
        case 2: return eAddBridgePortNotEnough;
        case 3: return eAddBridgeInvalidClient;
        case 4: return eAddBridgeNewBridgeFail;
        case 5: return eAddBridgeNewBridgeNodeFail;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EDssAddBridgeResultCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EDssAddBridgeResultCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EDssAddBridgeResultCode>() {
            public EDssAddBridgeResultCode findValueByNumber(int number) {
              return EDssAddBridgeResultCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(12);
    }

    private static final EDssAddBridgeResultCode[] VALUES = values();

    public static EDssAddBridgeResultCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EDssAddBridgeResultCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.EDssAddBridgeResultCode)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.EDssRmBridgeResultCode}
   */
  public enum EDssRmBridgeResultCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>eRmBridgeSucceed = 0;</code>
     */
    eRmBridgeSucceed(0, 0),
    /**
     * <code>eRmBridgeUnknown = 1;</code>
     */
    eRmBridgeUnknown(1, 1),
    /**
     * <code>eRmBridgeInvalidClient = 2;</code>
     */
    eRmBridgeInvalidClient(2, 2),
    ;

    /**
     * <code>eRmBridgeSucceed = 0;</code>
     */
    public static final int eRmBridgeSucceed_VALUE = 0;
    /**
     * <code>eRmBridgeUnknown = 1;</code>
     */
    public static final int eRmBridgeUnknown_VALUE = 1;
    /**
     * <code>eRmBridgeInvalidClient = 2;</code>
     */
    public static final int eRmBridgeInvalidClient_VALUE = 2;


    public final int getNumber() { return value; }

    public static EDssRmBridgeResultCode valueOf(int value) {
      switch (value) {
        case 0: return eRmBridgeSucceed;
        case 1: return eRmBridgeUnknown;
        case 2: return eRmBridgeInvalidClient;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EDssRmBridgeResultCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EDssRmBridgeResultCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EDssRmBridgeResultCode>() {
            public EDssRmBridgeResultCode findValueByNumber(int number) {
              return EDssRmBridgeResultCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(13);
    }

    private static final EDssRmBridgeResultCode[] VALUES = values();

    public static EDssRmBridgeResultCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EDssRmBridgeResultCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.EDssRmBridgeResultCode)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.ESendToBridgeResultCode}
   */
  public enum ESendToBridgeResultCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>eSendToBridgeSucceed = 0;</code>
     */
    eSendToBridgeSucceed(0, 0),
    /**
     * <code>eSendToBridgeBridgeHandleNotFound = 1;</code>
     */
    eSendToBridgeBridgeHandleNotFound(1, 1),
    /**
     * <code>eSendToBridgeBridgeHeadNotFound = 2;</code>
     */
    eSendToBridgeBridgeHeadNotFound(2, 2),
    /**
     * <code>eSendToBridgeWorkerIpNotFound = 3;</code>
     */
    eSendToBridgeWorkerIpNotFound(3, 3),
    /**
     * <code>eSendToBridgeSwitchRuleExisted = 4;</code>
     */
    eSendToBridgeSwitchRuleExisted(4, 4),
    /**
     * <code>eSendToBridgeAddSwitchRuleFail = 5;</code>
     */
    eSendToBridgeAddSwitchRuleFail(5, 5),
    /**
     * <code>eSendToBridgeCreateRcvGroupFail = 6;</code>
     */
    eSendToBridgeCreateRcvGroupFail(6, 6),
    /**
     * <code>eSendToBridgeInvalidClient = 7;</code>
     */
    eSendToBridgeInvalidClient(7, 7),
    /**
     * <code>eSendToBridgeGetMeetingFail = 8;</code>
     */
    eSendToBridgeGetMeetingFail(8, 8),
    ;

    /**
     * <code>eSendToBridgeSucceed = 0;</code>
     */
    public static final int eSendToBridgeSucceed_VALUE = 0;
    /**
     * <code>eSendToBridgeBridgeHandleNotFound = 1;</code>
     */
    public static final int eSendToBridgeBridgeHandleNotFound_VALUE = 1;
    /**
     * <code>eSendToBridgeBridgeHeadNotFound = 2;</code>
     */
    public static final int eSendToBridgeBridgeHeadNotFound_VALUE = 2;
    /**
     * <code>eSendToBridgeWorkerIpNotFound = 3;</code>
     */
    public static final int eSendToBridgeWorkerIpNotFound_VALUE = 3;
    /**
     * <code>eSendToBridgeSwitchRuleExisted = 4;</code>
     */
    public static final int eSendToBridgeSwitchRuleExisted_VALUE = 4;
    /**
     * <code>eSendToBridgeAddSwitchRuleFail = 5;</code>
     */
    public static final int eSendToBridgeAddSwitchRuleFail_VALUE = 5;
    /**
     * <code>eSendToBridgeCreateRcvGroupFail = 6;</code>
     */
    public static final int eSendToBridgeCreateRcvGroupFail_VALUE = 6;
    /**
     * <code>eSendToBridgeInvalidClient = 7;</code>
     */
    public static final int eSendToBridgeInvalidClient_VALUE = 7;
    /**
     * <code>eSendToBridgeGetMeetingFail = 8;</code>
     */
    public static final int eSendToBridgeGetMeetingFail_VALUE = 8;


    public final int getNumber() { return value; }

    public static ESendToBridgeResultCode valueOf(int value) {
      switch (value) {
        case 0: return eSendToBridgeSucceed;
        case 1: return eSendToBridgeBridgeHandleNotFound;
        case 2: return eSendToBridgeBridgeHeadNotFound;
        case 3: return eSendToBridgeWorkerIpNotFound;
        case 4: return eSendToBridgeSwitchRuleExisted;
        case 5: return eSendToBridgeAddSwitchRuleFail;
        case 6: return eSendToBridgeCreateRcvGroupFail;
        case 7: return eSendToBridgeInvalidClient;
        case 8: return eSendToBridgeGetMeetingFail;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ESendToBridgeResultCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<ESendToBridgeResultCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ESendToBridgeResultCode>() {
            public ESendToBridgeResultCode findValueByNumber(int number) {
              return ESendToBridgeResultCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(14);
    }

    private static final ESendToBridgeResultCode[] VALUES = values();

    public static ESendToBridgeResultCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private ESendToBridgeResultCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.ESendToBridgeResultCode)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.EStopSendToBridgeResultCode}
   */
  public enum EStopSendToBridgeResultCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>eStopSendToBridgeSucceed = 0;</code>
     */
    eStopSendToBridgeSucceed(0, 0),
    /**
     * <code>eStopSendToBridgeBridgeHandleNotFound = 1;</code>
     */
    eStopSendToBridgeBridgeHandleNotFound(1, 1),
    /**
     * <code>eStopSendToBridgeBridgeHeadNotFound = 2;</code>
     */
    eStopSendToBridgeBridgeHeadNotFound(2, 2),
    /**
     * <code>eStopSendToBridgeWorkerIpNotFound = 3;</code>
     */
    eStopSendToBridgeWorkerIpNotFound(3, 3),
    /**
     * <code>eStopSendToBridgeSwitchRuleNotExist = 4;</code>
     */
    eStopSendToBridgeSwitchRuleNotExist(4, 4),
    /**
     * <code>eStopSendToBridgeAddSwitchRuleFail = 5;</code>
     */
    eStopSendToBridgeAddSwitchRuleFail(5, 5),
    /**
     * <code>eStopSendToBridgeDestroyRcvGroupFail = 6;</code>
     */
    eStopSendToBridgeDestroyRcvGroupFail(6, 6),
    /**
     * <code>eStopSendToBridgeRcvGroupNotFound = 7;</code>
     */
    eStopSendToBridgeRcvGroupNotFound(7, 7),
    /**
     * <code>eStopSendToBridgeInvalidClient = 8;</code>
     */
    eStopSendToBridgeInvalidClient(8, 8),
    /**
     * <code>eStopSendToBridgeGetMeetingFail = 9;</code>
     */
    eStopSendToBridgeGetMeetingFail(9, 9),
    /**
     * <code>eStopSendToBridgeGetBridgeFail = 10;</code>
     */
    eStopSendToBridgeGetBridgeFail(10, 10),
    /**
     * <code>eStopSendToBridgeStopFail = 11;</code>
     */
    eStopSendToBridgeStopFail(11, 11),
    ;

    /**
     * <code>eStopSendToBridgeSucceed = 0;</code>
     */
    public static final int eStopSendToBridgeSucceed_VALUE = 0;
    /**
     * <code>eStopSendToBridgeBridgeHandleNotFound = 1;</code>
     */
    public static final int eStopSendToBridgeBridgeHandleNotFound_VALUE = 1;
    /**
     * <code>eStopSendToBridgeBridgeHeadNotFound = 2;</code>
     */
    public static final int eStopSendToBridgeBridgeHeadNotFound_VALUE = 2;
    /**
     * <code>eStopSendToBridgeWorkerIpNotFound = 3;</code>
     */
    public static final int eStopSendToBridgeWorkerIpNotFound_VALUE = 3;
    /**
     * <code>eStopSendToBridgeSwitchRuleNotExist = 4;</code>
     */
    public static final int eStopSendToBridgeSwitchRuleNotExist_VALUE = 4;
    /**
     * <code>eStopSendToBridgeAddSwitchRuleFail = 5;</code>
     */
    public static final int eStopSendToBridgeAddSwitchRuleFail_VALUE = 5;
    /**
     * <code>eStopSendToBridgeDestroyRcvGroupFail = 6;</code>
     */
    public static final int eStopSendToBridgeDestroyRcvGroupFail_VALUE = 6;
    /**
     * <code>eStopSendToBridgeRcvGroupNotFound = 7;</code>
     */
    public static final int eStopSendToBridgeRcvGroupNotFound_VALUE = 7;
    /**
     * <code>eStopSendToBridgeInvalidClient = 8;</code>
     */
    public static final int eStopSendToBridgeInvalidClient_VALUE = 8;
    /**
     * <code>eStopSendToBridgeGetMeetingFail = 9;</code>
     */
    public static final int eStopSendToBridgeGetMeetingFail_VALUE = 9;
    /**
     * <code>eStopSendToBridgeGetBridgeFail = 10;</code>
     */
    public static final int eStopSendToBridgeGetBridgeFail_VALUE = 10;
    /**
     * <code>eStopSendToBridgeStopFail = 11;</code>
     */
    public static final int eStopSendToBridgeStopFail_VALUE = 11;


    public final int getNumber() { return value; }

    public static EStopSendToBridgeResultCode valueOf(int value) {
      switch (value) {
        case 0: return eStopSendToBridgeSucceed;
        case 1: return eStopSendToBridgeBridgeHandleNotFound;
        case 2: return eStopSendToBridgeBridgeHeadNotFound;
        case 3: return eStopSendToBridgeWorkerIpNotFound;
        case 4: return eStopSendToBridgeSwitchRuleNotExist;
        case 5: return eStopSendToBridgeAddSwitchRuleFail;
        case 6: return eStopSendToBridgeDestroyRcvGroupFail;
        case 7: return eStopSendToBridgeRcvGroupNotFound;
        case 8: return eStopSendToBridgeInvalidClient;
        case 9: return eStopSendToBridgeGetMeetingFail;
        case 10: return eStopSendToBridgeGetBridgeFail;
        case 11: return eStopSendToBridgeStopFail;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EStopSendToBridgeResultCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EStopSendToBridgeResultCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EStopSendToBridgeResultCode>() {
            public EStopSendToBridgeResultCode findValueByNumber(int number) {
              return EStopSendToBridgeResultCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(15);
    }

    private static final EStopSendToBridgeResultCode[] VALUES = values();

    public static EStopSendToBridgeResultCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EStopSendToBridgeResultCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.EStopSendToBridgeResultCode)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.EReceiveFromBridgeResultCode}
   */
  public enum EReceiveFromBridgeResultCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>eReceiveFromBridgeSucceed = 0;</code>
     */
    eReceiveFromBridgeSucceed(0, 0),
    /**
     * <code>eReceiveFromBridgeFailToPullWorkerIntoBridge = 1;</code>
     */
    eReceiveFromBridgeFailToPullWorkerIntoBridge(1, 1),
    /**
     * <code>eReceiveFromBridgeFailToGetBridgeNodeFromBridge = 2;</code>
     */
    eReceiveFromBridgeFailToGetBridgeNodeFromBridge(2, 2),
    /**
     * <code>eReceiveFromBridgeBridgeHandleNotFound = 3;</code>
     */
    eReceiveFromBridgeBridgeHandleNotFound(3, 3),
    /**
     * <code>eReceiveFromBridgeBridgeHeadNotFound = 4;</code>
     */
    eReceiveFromBridgeBridgeHeadNotFound(4, 4),
    /**
     * <code>eReceiveFromBridgeWorkerIpNotFound = 5;</code>
     */
    eReceiveFromBridgeWorkerIpNotFound(5, 5),
    /**
     * <code>eReceiveFromBridgeSwitchRuleExisted = 6;</code>
     */
    eReceiveFromBridgeSwitchRuleExisted(6, 6),
    /**
     * <code>eReceiveFromBridgeAddSwitchRuleFail = 7;</code>
     */
    eReceiveFromBridgeAddSwitchRuleFail(7, 7),
    /**
     * <code>eReceiveFromBridgeCreateRcvGroupFail = 8;</code>
     */
    eReceiveFromBridgeCreateRcvGroupFail(8, 8),
    /**
     * <code>eReceiveFromBridgeInvalidClient = 9;</code>
     */
    eReceiveFromBridgeInvalidClient(9, 9),
    /**
     * <code>eReceiveFromBridgeGetMeetingFail = 10;</code>
     */
    eReceiveFromBridgeGetMeetingFail(10, 10),
    /**
     * <code>eReceiveFromBridgeGetBridgeFail = 11;</code>
     */
    eReceiveFromBridgeGetBridgeFail(11, 11),
    /**
     * <code>eReceiveFromBridgeReceiveFail = 12;</code>
     */
    eReceiveFromBridgeReceiveFail(12, 12),
    ;

    /**
     * <code>eReceiveFromBridgeSucceed = 0;</code>
     */
    public static final int eReceiveFromBridgeSucceed_VALUE = 0;
    /**
     * <code>eReceiveFromBridgeFailToPullWorkerIntoBridge = 1;</code>
     */
    public static final int eReceiveFromBridgeFailToPullWorkerIntoBridge_VALUE = 1;
    /**
     * <code>eReceiveFromBridgeFailToGetBridgeNodeFromBridge = 2;</code>
     */
    public static final int eReceiveFromBridgeFailToGetBridgeNodeFromBridge_VALUE = 2;
    /**
     * <code>eReceiveFromBridgeBridgeHandleNotFound = 3;</code>
     */
    public static final int eReceiveFromBridgeBridgeHandleNotFound_VALUE = 3;
    /**
     * <code>eReceiveFromBridgeBridgeHeadNotFound = 4;</code>
     */
    public static final int eReceiveFromBridgeBridgeHeadNotFound_VALUE = 4;
    /**
     * <code>eReceiveFromBridgeWorkerIpNotFound = 5;</code>
     */
    public static final int eReceiveFromBridgeWorkerIpNotFound_VALUE = 5;
    /**
     * <code>eReceiveFromBridgeSwitchRuleExisted = 6;</code>
     */
    public static final int eReceiveFromBridgeSwitchRuleExisted_VALUE = 6;
    /**
     * <code>eReceiveFromBridgeAddSwitchRuleFail = 7;</code>
     */
    public static final int eReceiveFromBridgeAddSwitchRuleFail_VALUE = 7;
    /**
     * <code>eReceiveFromBridgeCreateRcvGroupFail = 8;</code>
     */
    public static final int eReceiveFromBridgeCreateRcvGroupFail_VALUE = 8;
    /**
     * <code>eReceiveFromBridgeInvalidClient = 9;</code>
     */
    public static final int eReceiveFromBridgeInvalidClient_VALUE = 9;
    /**
     * <code>eReceiveFromBridgeGetMeetingFail = 10;</code>
     */
    public static final int eReceiveFromBridgeGetMeetingFail_VALUE = 10;
    /**
     * <code>eReceiveFromBridgeGetBridgeFail = 11;</code>
     */
    public static final int eReceiveFromBridgeGetBridgeFail_VALUE = 11;
    /**
     * <code>eReceiveFromBridgeReceiveFail = 12;</code>
     */
    public static final int eReceiveFromBridgeReceiveFail_VALUE = 12;


    public final int getNumber() { return value; }

    public static EReceiveFromBridgeResultCode valueOf(int value) {
      switch (value) {
        case 0: return eReceiveFromBridgeSucceed;
        case 1: return eReceiveFromBridgeFailToPullWorkerIntoBridge;
        case 2: return eReceiveFromBridgeFailToGetBridgeNodeFromBridge;
        case 3: return eReceiveFromBridgeBridgeHandleNotFound;
        case 4: return eReceiveFromBridgeBridgeHeadNotFound;
        case 5: return eReceiveFromBridgeWorkerIpNotFound;
        case 6: return eReceiveFromBridgeSwitchRuleExisted;
        case 7: return eReceiveFromBridgeAddSwitchRuleFail;
        case 8: return eReceiveFromBridgeCreateRcvGroupFail;
        case 9: return eReceiveFromBridgeInvalidClient;
        case 10: return eReceiveFromBridgeGetMeetingFail;
        case 11: return eReceiveFromBridgeGetBridgeFail;
        case 12: return eReceiveFromBridgeReceiveFail;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EReceiveFromBridgeResultCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EReceiveFromBridgeResultCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EReceiveFromBridgeResultCode>() {
            public EReceiveFromBridgeResultCode findValueByNumber(int number) {
              return EReceiveFromBridgeResultCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(16);
    }

    private static final EReceiveFromBridgeResultCode[] VALUES = values();

    public static EReceiveFromBridgeResultCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EReceiveFromBridgeResultCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.EReceiveFromBridgeResultCode)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.EStopReceiveFromBridgeResultCode}
   */
  public enum EStopReceiveFromBridgeResultCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>eStopReceiveFromBridgeSucceed = 0;</code>
     */
    eStopReceiveFromBridgeSucceed(0, 0),
    /**
     * <code>eStopReceiveFromBridgeBridgeHandleNotFound = 1;</code>
     */
    eStopReceiveFromBridgeBridgeHandleNotFound(1, 1),
    /**
     * <code>eStopReceiveFromBridgeBridgeHeadNotFound = 2;</code>
     */
    eStopReceiveFromBridgeBridgeHeadNotFound(2, 2),
    /**
     * <code>eStopReceiveFromBridgeWorkerIpNotFound = 3;</code>
     */
    eStopReceiveFromBridgeWorkerIpNotFound(3, 3),
    /**
     * <code>eStopReceiveFromBridgeSwitchRuleNotExist = 4;</code>
     */
    eStopReceiveFromBridgeSwitchRuleNotExist(4, 4),
    /**
     * <code>eStopReceiveFromBridgeFindSwitchRuleFail = 5;</code>
     */
    eStopReceiveFromBridgeFindSwitchRuleFail(5, 5),
    /**
     * <code>eStopReceiveFromBridgeDestroyRcvGroupFail = 6;</code>
     */
    eStopReceiveFromBridgeDestroyRcvGroupFail(6, 6),
    /**
     * <code>eStopReceiveFromBridgeRcvGroupNotFound = 7;</code>
     */
    eStopReceiveFromBridgeRcvGroupNotFound(7, 7),
    /**
     * <code>eStopReceiveFromBridgeInvalidClient = 8;</code>
     */
    eStopReceiveFromBridgeInvalidClient(8, 8),
    /**
     * <code>eStopReceiveFromBridgeGetMeetingFail = 9;</code>
     */
    eStopReceiveFromBridgeGetMeetingFail(9, 9),
    /**
     * <code>eStopReceiveFromBridgeGetBridgeFail = 10;</code>
     */
    eStopReceiveFromBridgeGetBridgeFail(10, 10),
    /**
     * <code>eStopReceiveFromBridgeReceiveFail = 11;</code>
     */
    eStopReceiveFromBridgeReceiveFail(11, 11),
    ;

    /**
     * <code>eStopReceiveFromBridgeSucceed = 0;</code>
     */
    public static final int eStopReceiveFromBridgeSucceed_VALUE = 0;
    /**
     * <code>eStopReceiveFromBridgeBridgeHandleNotFound = 1;</code>
     */
    public static final int eStopReceiveFromBridgeBridgeHandleNotFound_VALUE = 1;
    /**
     * <code>eStopReceiveFromBridgeBridgeHeadNotFound = 2;</code>
     */
    public static final int eStopReceiveFromBridgeBridgeHeadNotFound_VALUE = 2;
    /**
     * <code>eStopReceiveFromBridgeWorkerIpNotFound = 3;</code>
     */
    public static final int eStopReceiveFromBridgeWorkerIpNotFound_VALUE = 3;
    /**
     * <code>eStopReceiveFromBridgeSwitchRuleNotExist = 4;</code>
     */
    public static final int eStopReceiveFromBridgeSwitchRuleNotExist_VALUE = 4;
    /**
     * <code>eStopReceiveFromBridgeFindSwitchRuleFail = 5;</code>
     */
    public static final int eStopReceiveFromBridgeFindSwitchRuleFail_VALUE = 5;
    /**
     * <code>eStopReceiveFromBridgeDestroyRcvGroupFail = 6;</code>
     */
    public static final int eStopReceiveFromBridgeDestroyRcvGroupFail_VALUE = 6;
    /**
     * <code>eStopReceiveFromBridgeRcvGroupNotFound = 7;</code>
     */
    public static final int eStopReceiveFromBridgeRcvGroupNotFound_VALUE = 7;
    /**
     * <code>eStopReceiveFromBridgeInvalidClient = 8;</code>
     */
    public static final int eStopReceiveFromBridgeInvalidClient_VALUE = 8;
    /**
     * <code>eStopReceiveFromBridgeGetMeetingFail = 9;</code>
     */
    public static final int eStopReceiveFromBridgeGetMeetingFail_VALUE = 9;
    /**
     * <code>eStopReceiveFromBridgeGetBridgeFail = 10;</code>
     */
    public static final int eStopReceiveFromBridgeGetBridgeFail_VALUE = 10;
    /**
     * <code>eStopReceiveFromBridgeReceiveFail = 11;</code>
     */
    public static final int eStopReceiveFromBridgeReceiveFail_VALUE = 11;


    public final int getNumber() { return value; }

    public static EStopReceiveFromBridgeResultCode valueOf(int value) {
      switch (value) {
        case 0: return eStopReceiveFromBridgeSucceed;
        case 1: return eStopReceiveFromBridgeBridgeHandleNotFound;
        case 2: return eStopReceiveFromBridgeBridgeHeadNotFound;
        case 3: return eStopReceiveFromBridgeWorkerIpNotFound;
        case 4: return eStopReceiveFromBridgeSwitchRuleNotExist;
        case 5: return eStopReceiveFromBridgeFindSwitchRuleFail;
        case 6: return eStopReceiveFromBridgeDestroyRcvGroupFail;
        case 7: return eStopReceiveFromBridgeRcvGroupNotFound;
        case 8: return eStopReceiveFromBridgeInvalidClient;
        case 9: return eStopReceiveFromBridgeGetMeetingFail;
        case 10: return eStopReceiveFromBridgeGetBridgeFail;
        case 11: return eStopReceiveFromBridgeReceiveFail;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EStopReceiveFromBridgeResultCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EStopReceiveFromBridgeResultCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EStopReceiveFromBridgeResultCode>() {
            public EStopReceiveFromBridgeResultCode findValueByNumber(int number) {
              return EStopReceiveFromBridgeResultCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(17);
    }

    private static final EStopReceiveFromBridgeResultCode[] VALUES = values();

    public static EStopReceiveFromBridgeResultCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EStopReceiveFromBridgeResultCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.EStopReceiveFromBridgeResultCode)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.EAddSwitchResultCode}
   */
  public enum EAddSwitchResultCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>eAddSwitchSucceed = 0;</code>
     */
    eAddSwitchSucceed(0, 0),
    /**
     * <code>eAddSwitchInvalidParam = 1;</code>
     */
    eAddSwitchInvalidParam(1, 1),
    /**
     * <code>eAddSwitchClientNotFound = 2;</code>
     */
    eAddSwitchClientNotFound(2, 2),
    /**
     * <code>eAddSwitchUnknownFail = 3;</code>
     */
    eAddSwitchUnknownFail(3, 3),
    /**
     * <code>eAddSwitchCreateRcvGroupFail = 4;</code>
     */
    eAddSwitchCreateRcvGroupFail(4, 4),
    /**
     * <code>eAddSwitchCreateMapRcvGroupFail = 5;</code>
     */
    eAddSwitchCreateMapRcvGroupFail(5, 5),
    /**
     * <code>eAddSwitchValidatePortFail = 6;</code>
     */
    eAddSwitchValidatePortFail(6, 6),
    /**
     * <code>eAddSwitchAddRtpRuleFail = 7;</code>
     */
    eAddSwitchAddRtpRuleFail(7, 7),
    /**
     * <code>eAddSwitchAddRtcpRuleFail = 8;</code>
     */
    eAddSwitchAddRtcpRuleFail(8, 8),
    /**
     * <code>eAddSwitchInnerError = 9;</code>
     */
    eAddSwitchInnerError(9, 9),
    /**
     * <code>eAddSwitchRcvPortIpNotFound = 10;</code>
     */
    eAddSwitchRcvPortIpNotFound(10, 10),
    /**
     * <code>eAddSwitchSwitchExisted = 11;</code>
     */
    eAddSwitchSwitchExisted(11, 11),
    /**
     * <code>eAddSwitchInvalidClient = 12;</code>
     */
    eAddSwitchInvalidClient(12, 12),
    ;

    /**
     * <code>eAddSwitchSucceed = 0;</code>
     */
    public static final int eAddSwitchSucceed_VALUE = 0;
    /**
     * <code>eAddSwitchInvalidParam = 1;</code>
     */
    public static final int eAddSwitchInvalidParam_VALUE = 1;
    /**
     * <code>eAddSwitchClientNotFound = 2;</code>
     */
    public static final int eAddSwitchClientNotFound_VALUE = 2;
    /**
     * <code>eAddSwitchUnknownFail = 3;</code>
     */
    public static final int eAddSwitchUnknownFail_VALUE = 3;
    /**
     * <code>eAddSwitchCreateRcvGroupFail = 4;</code>
     */
    public static final int eAddSwitchCreateRcvGroupFail_VALUE = 4;
    /**
     * <code>eAddSwitchCreateMapRcvGroupFail = 5;</code>
     */
    public static final int eAddSwitchCreateMapRcvGroupFail_VALUE = 5;
    /**
     * <code>eAddSwitchValidatePortFail = 6;</code>
     */
    public static final int eAddSwitchValidatePortFail_VALUE = 6;
    /**
     * <code>eAddSwitchAddRtpRuleFail = 7;</code>
     */
    public static final int eAddSwitchAddRtpRuleFail_VALUE = 7;
    /**
     * <code>eAddSwitchAddRtcpRuleFail = 8;</code>
     */
    public static final int eAddSwitchAddRtcpRuleFail_VALUE = 8;
    /**
     * <code>eAddSwitchInnerError = 9;</code>
     */
    public static final int eAddSwitchInnerError_VALUE = 9;
    /**
     * <code>eAddSwitchRcvPortIpNotFound = 10;</code>
     */
    public static final int eAddSwitchRcvPortIpNotFound_VALUE = 10;
    /**
     * <code>eAddSwitchSwitchExisted = 11;</code>
     */
    public static final int eAddSwitchSwitchExisted_VALUE = 11;
    /**
     * <code>eAddSwitchInvalidClient = 12;</code>
     */
    public static final int eAddSwitchInvalidClient_VALUE = 12;


    public final int getNumber() { return value; }

    public static EAddSwitchResultCode valueOf(int value) {
      switch (value) {
        case 0: return eAddSwitchSucceed;
        case 1: return eAddSwitchInvalidParam;
        case 2: return eAddSwitchClientNotFound;
        case 3: return eAddSwitchUnknownFail;
        case 4: return eAddSwitchCreateRcvGroupFail;
        case 5: return eAddSwitchCreateMapRcvGroupFail;
        case 6: return eAddSwitchValidatePortFail;
        case 7: return eAddSwitchAddRtpRuleFail;
        case 8: return eAddSwitchAddRtcpRuleFail;
        case 9: return eAddSwitchInnerError;
        case 10: return eAddSwitchRcvPortIpNotFound;
        case 11: return eAddSwitchSwitchExisted;
        case 12: return eAddSwitchInvalidClient;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EAddSwitchResultCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EAddSwitchResultCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EAddSwitchResultCode>() {
            public EAddSwitchResultCode findValueByNumber(int number) {
              return EAddSwitchResultCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(18);
    }

    private static final EAddSwitchResultCode[] VALUES = values();

    public static EAddSwitchResultCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EAddSwitchResultCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.EAddSwitchResultCode)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.ERmSwitchResultCode}
   */
  public enum ERmSwitchResultCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>eRmSwitchSucceed = 0;</code>
     */
    eRmSwitchSucceed(0, 0),
    /**
     * <code>eRmSwitchInvalidParam = 1;</code>
     */
    eRmSwitchInvalidParam(1, 1),
    /**
     * <code>eRmSwitchClientNotFound = 2;</code>
     */
    eRmSwitchClientNotFound(2, 2),
    /**
     * <code>eRmSwitchUnknownFail = 3;</code>
     */
    eRmSwitchUnknownFail(3, 3),
    /**
     * <code>eRmSwitchRcvPortIpNotFound = 4;</code>
     */
    eRmSwitchRcvPortIpNotFound(4, 4),
    /**
     * <code>eRmSwitchRcvPortNotFoundOnWorker = 5;</code>
     */
    eRmSwitchRcvPortNotFoundOnWorker(5, 5),
    /**
     * <code>eRmSwitchSwitchNotExisted = 6;</code>
     */
    eRmSwitchSwitchNotExisted(6, 6),
    /**
     * <code>eRmSwitchInvalidClient = 7;</code>
     */
    eRmSwitchInvalidClient(7, 7),
    ;

    /**
     * <code>eRmSwitchSucceed = 0;</code>
     */
    public static final int eRmSwitchSucceed_VALUE = 0;
    /**
     * <code>eRmSwitchInvalidParam = 1;</code>
     */
    public static final int eRmSwitchInvalidParam_VALUE = 1;
    /**
     * <code>eRmSwitchClientNotFound = 2;</code>
     */
    public static final int eRmSwitchClientNotFound_VALUE = 2;
    /**
     * <code>eRmSwitchUnknownFail = 3;</code>
     */
    public static final int eRmSwitchUnknownFail_VALUE = 3;
    /**
     * <code>eRmSwitchRcvPortIpNotFound = 4;</code>
     */
    public static final int eRmSwitchRcvPortIpNotFound_VALUE = 4;
    /**
     * <code>eRmSwitchRcvPortNotFoundOnWorker = 5;</code>
     */
    public static final int eRmSwitchRcvPortNotFoundOnWorker_VALUE = 5;
    /**
     * <code>eRmSwitchSwitchNotExisted = 6;</code>
     */
    public static final int eRmSwitchSwitchNotExisted_VALUE = 6;
    /**
     * <code>eRmSwitchInvalidClient = 7;</code>
     */
    public static final int eRmSwitchInvalidClient_VALUE = 7;


    public final int getNumber() { return value; }

    public static ERmSwitchResultCode valueOf(int value) {
      switch (value) {
        case 0: return eRmSwitchSucceed;
        case 1: return eRmSwitchInvalidParam;
        case 2: return eRmSwitchClientNotFound;
        case 3: return eRmSwitchUnknownFail;
        case 4: return eRmSwitchRcvPortIpNotFound;
        case 5: return eRmSwitchRcvPortNotFoundOnWorker;
        case 6: return eRmSwitchSwitchNotExisted;
        case 7: return eRmSwitchInvalidClient;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ERmSwitchResultCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<ERmSwitchResultCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ERmSwitchResultCode>() {
            public ERmSwitchResultCode findValueByNumber(int number) {
              return ERmSwitchResultCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(19);
    }

    private static final ERmSwitchResultCode[] VALUES = values();

    public static ERmSwitchResultCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private ERmSwitchResultCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.ERmSwitchResultCode)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.EAddM2OneSwitchResultCode}
   */
  public enum EAddM2OneSwitchResultCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>eAddM2OneSwitchSucceed = 0;</code>
     */
    eAddM2OneSwitchSucceed(0, 0),
    /**
     * <code>eAddM2OneSwitchInvalidParam = 1;</code>
     */
    eAddM2OneSwitchInvalidParam(1, 1),
    /**
     * <code>eAddM2OneSwitchClientNotFound = 2;</code>
     */
    eAddM2OneSwitchClientNotFound(2, 2),
    /**
     * <code>eAddM2OneSwitchUnknownFail = 3;</code>
     */
    eAddM2OneSwitchUnknownFail(3, 3),
    /**
     * <code>eAddM2OneSwitchCreateRcvGroupFail = 4;</code>
     */
    eAddM2OneSwitchCreateRcvGroupFail(4, 4),
    /**
     * <code>eAddM2OneSwitchCreateMapRcvGroupFail = 5;</code>
     */
    eAddM2OneSwitchCreateMapRcvGroupFail(5, 5),
    /**
     * <code>eAddM2OneSwitchValidatePortFail = 6;</code>
     */
    eAddM2OneSwitchValidatePortFail(6, 6),
    /**
     * <code>eAddM2OneSwitchAddRtpRuleFail = 7;</code>
     */
    eAddM2OneSwitchAddRtpRuleFail(7, 7),
    /**
     * <code>eAddM2OneSwitchAddRtcpRuleFail = 8;</code>
     */
    eAddM2OneSwitchAddRtcpRuleFail(8, 8),
    /**
     * <code>eAddM2OneSwitchInnerError = 9;</code>
     */
    eAddM2OneSwitchInnerError(9, 9),
    /**
     * <code>eAddM2OneSwitchRcvPortIpNotFound = 10;</code>
     */
    eAddM2OneSwitchRcvPortIpNotFound(10, 10),
    /**
     * <code>eAddM2OneSwitchSwitchExisted = 11;</code>
     */
    eAddM2OneSwitchSwitchExisted(11, 11),
    /**
     * <code>eAddM2OneSwitchInvalidClient = 12;</code>
     */
    eAddM2OneSwitchInvalidClient(12, 12),
    ;

    /**
     * <code>eAddM2OneSwitchSucceed = 0;</code>
     */
    public static final int eAddM2OneSwitchSucceed_VALUE = 0;
    /**
     * <code>eAddM2OneSwitchInvalidParam = 1;</code>
     */
    public static final int eAddM2OneSwitchInvalidParam_VALUE = 1;
    /**
     * <code>eAddM2OneSwitchClientNotFound = 2;</code>
     */
    public static final int eAddM2OneSwitchClientNotFound_VALUE = 2;
    /**
     * <code>eAddM2OneSwitchUnknownFail = 3;</code>
     */
    public static final int eAddM2OneSwitchUnknownFail_VALUE = 3;
    /**
     * <code>eAddM2OneSwitchCreateRcvGroupFail = 4;</code>
     */
    public static final int eAddM2OneSwitchCreateRcvGroupFail_VALUE = 4;
    /**
     * <code>eAddM2OneSwitchCreateMapRcvGroupFail = 5;</code>
     */
    public static final int eAddM2OneSwitchCreateMapRcvGroupFail_VALUE = 5;
    /**
     * <code>eAddM2OneSwitchValidatePortFail = 6;</code>
     */
    public static final int eAddM2OneSwitchValidatePortFail_VALUE = 6;
    /**
     * <code>eAddM2OneSwitchAddRtpRuleFail = 7;</code>
     */
    public static final int eAddM2OneSwitchAddRtpRuleFail_VALUE = 7;
    /**
     * <code>eAddM2OneSwitchAddRtcpRuleFail = 8;</code>
     */
    public static final int eAddM2OneSwitchAddRtcpRuleFail_VALUE = 8;
    /**
     * <code>eAddM2OneSwitchInnerError = 9;</code>
     */
    public static final int eAddM2OneSwitchInnerError_VALUE = 9;
    /**
     * <code>eAddM2OneSwitchRcvPortIpNotFound = 10;</code>
     */
    public static final int eAddM2OneSwitchRcvPortIpNotFound_VALUE = 10;
    /**
     * <code>eAddM2OneSwitchSwitchExisted = 11;</code>
     */
    public static final int eAddM2OneSwitchSwitchExisted_VALUE = 11;
    /**
     * <code>eAddM2OneSwitchInvalidClient = 12;</code>
     */
    public static final int eAddM2OneSwitchInvalidClient_VALUE = 12;


    public final int getNumber() { return value; }

    public static EAddM2OneSwitchResultCode valueOf(int value) {
      switch (value) {
        case 0: return eAddM2OneSwitchSucceed;
        case 1: return eAddM2OneSwitchInvalidParam;
        case 2: return eAddM2OneSwitchClientNotFound;
        case 3: return eAddM2OneSwitchUnknownFail;
        case 4: return eAddM2OneSwitchCreateRcvGroupFail;
        case 5: return eAddM2OneSwitchCreateMapRcvGroupFail;
        case 6: return eAddM2OneSwitchValidatePortFail;
        case 7: return eAddM2OneSwitchAddRtpRuleFail;
        case 8: return eAddM2OneSwitchAddRtcpRuleFail;
        case 9: return eAddM2OneSwitchInnerError;
        case 10: return eAddM2OneSwitchRcvPortIpNotFound;
        case 11: return eAddM2OneSwitchSwitchExisted;
        case 12: return eAddM2OneSwitchInvalidClient;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EAddM2OneSwitchResultCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EAddM2OneSwitchResultCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EAddM2OneSwitchResultCode>() {
            public EAddM2OneSwitchResultCode findValueByNumber(int number) {
              return EAddM2OneSwitchResultCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(20);
    }

    private static final EAddM2OneSwitchResultCode[] VALUES = values();

    public static EAddM2OneSwitchResultCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EAddM2OneSwitchResultCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.EAddM2OneSwitchResultCode)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.ERmM2OneSwitchResultCode}
   */
  public enum ERmM2OneSwitchResultCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>eRmM2OneSwitchSucceed = 0;</code>
     */
    eRmM2OneSwitchSucceed(0, 0),
    /**
     * <code>eRmM2OneSwitchInvalidParam = 1;</code>
     */
    eRmM2OneSwitchInvalidParam(1, 1),
    /**
     * <code>eRmM2OneSwitchClientNotFound = 2;</code>
     */
    eRmM2OneSwitchClientNotFound(2, 2),
    /**
     * <code>eRmM2OneSwitchUnknownFail = 3;</code>
     */
    eRmM2OneSwitchUnknownFail(3, 3),
    /**
     * <code>eRmM2OneSwitchRcvPortIpNotFound = 4;</code>
     */
    eRmM2OneSwitchRcvPortIpNotFound(4, 4),
    /**
     * <code>eRmM2OneSwitchRcvPortNotFoundOnWorker = 5;</code>
     */
    eRmM2OneSwitchRcvPortNotFoundOnWorker(5, 5),
    /**
     * <code>eRmM2OneSwitchRuleNotFound = 6;</code>
     */
    eRmM2OneSwitchRuleNotFound(6, 6),
    /**
     * <code>eRmM2OneSwitchFoundRuleByRcvDstFail = 7;</code>
     */
    eRmM2OneSwitchFoundRuleByRcvDstFail(7, 7),
    /**
     * <code>eRmM2OneSwitchInvalidClient = 8;</code>
     */
    eRmM2OneSwitchInvalidClient(8, 8),
    ;

    /**
     * <code>eRmM2OneSwitchSucceed = 0;</code>
     */
    public static final int eRmM2OneSwitchSucceed_VALUE = 0;
    /**
     * <code>eRmM2OneSwitchInvalidParam = 1;</code>
     */
    public static final int eRmM2OneSwitchInvalidParam_VALUE = 1;
    /**
     * <code>eRmM2OneSwitchClientNotFound = 2;</code>
     */
    public static final int eRmM2OneSwitchClientNotFound_VALUE = 2;
    /**
     * <code>eRmM2OneSwitchUnknownFail = 3;</code>
     */
    public static final int eRmM2OneSwitchUnknownFail_VALUE = 3;
    /**
     * <code>eRmM2OneSwitchRcvPortIpNotFound = 4;</code>
     */
    public static final int eRmM2OneSwitchRcvPortIpNotFound_VALUE = 4;
    /**
     * <code>eRmM2OneSwitchRcvPortNotFoundOnWorker = 5;</code>
     */
    public static final int eRmM2OneSwitchRcvPortNotFoundOnWorker_VALUE = 5;
    /**
     * <code>eRmM2OneSwitchRuleNotFound = 6;</code>
     */
    public static final int eRmM2OneSwitchRuleNotFound_VALUE = 6;
    /**
     * <code>eRmM2OneSwitchFoundRuleByRcvDstFail = 7;</code>
     */
    public static final int eRmM2OneSwitchFoundRuleByRcvDstFail_VALUE = 7;
    /**
     * <code>eRmM2OneSwitchInvalidClient = 8;</code>
     */
    public static final int eRmM2OneSwitchInvalidClient_VALUE = 8;


    public final int getNumber() { return value; }

    public static ERmM2OneSwitchResultCode valueOf(int value) {
      switch (value) {
        case 0: return eRmM2OneSwitchSucceed;
        case 1: return eRmM2OneSwitchInvalidParam;
        case 2: return eRmM2OneSwitchClientNotFound;
        case 3: return eRmM2OneSwitchUnknownFail;
        case 4: return eRmM2OneSwitchRcvPortIpNotFound;
        case 5: return eRmM2OneSwitchRcvPortNotFoundOnWorker;
        case 6: return eRmM2OneSwitchRuleNotFound;
        case 7: return eRmM2OneSwitchFoundRuleByRcvDstFail;
        case 8: return eRmM2OneSwitchInvalidClient;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ERmM2OneSwitchResultCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<ERmM2OneSwitchResultCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ERmM2OneSwitchResultCode>() {
            public ERmM2OneSwitchResultCode findValueByNumber(int number) {
              return ERmM2OneSwitchResultCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(21);
    }

    private static final ERmM2OneSwitchResultCode[] VALUES = values();

    public static ERmM2OneSwitchResultCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private ERmM2OneSwitchResultCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.ERmM2OneSwitchResultCode)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.EAddDumpSwitchResultCode}
   */
  public enum EAddDumpSwitchResultCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>eAddDumpSwitchSucceed = 0;</code>
     */
    eAddDumpSwitchSucceed(0, 0),
    /**
     * <code>eAddDumpSwitchInvalidParam = 1;</code>
     */
    eAddDumpSwitchInvalidParam(1, 1),
    /**
     * <code>eAddDumpSwitchClientNotFound = 2;</code>
     */
    eAddDumpSwitchClientNotFound(2, 2),
    /**
     * <code>eAddDumpSwitchUnknownFail = 3;</code>
     */
    eAddDumpSwitchUnknownFail(3, 3),
    /**
     * <code>eAddDumpSwitchCreateRcvGroupFail = 4;</code>
     */
    eAddDumpSwitchCreateRcvGroupFail(4, 4),
    /**
     * <code>eAddDumpSwitchCreateMapRcvGroupFail = 5;</code>
     */
    eAddDumpSwitchCreateMapRcvGroupFail(5, 5),
    /**
     * <code>eAddDumpSwitchValidatePortFail = 6;</code>
     */
    eAddDumpSwitchValidatePortFail(6, 6),
    /**
     * <code>eAddDumpSwitchAddRtpRuleFail = 7;</code>
     */
    eAddDumpSwitchAddRtpRuleFail(7, 7),
    /**
     * <code>eAddDumpSwitchAddRtcpRuleFail = 8;</code>
     */
    eAddDumpSwitchAddRtcpRuleFail(8, 8),
    /**
     * <code>eAddDumpSwitchInnerError = 9;</code>
     */
    eAddDumpSwitchInnerError(9, 9),
    /**
     * <code>eAddDumpSwitchRcvPortIpNotFound = 10;</code>
     */
    eAddDumpSwitchRcvPortIpNotFound(10, 10),
    /**
     * <code>eAddDumpSwitchSwitchExisted = 11;</code>
     */
    eAddDumpSwitchSwitchExisted(11, 11),
    /**
     * <code>eAddDumpSwitchInvalidClient = 12;</code>
     */
    eAddDumpSwitchInvalidClient(12, 12),
    ;

    /**
     * <code>eAddDumpSwitchSucceed = 0;</code>
     */
    public static final int eAddDumpSwitchSucceed_VALUE = 0;
    /**
     * <code>eAddDumpSwitchInvalidParam = 1;</code>
     */
    public static final int eAddDumpSwitchInvalidParam_VALUE = 1;
    /**
     * <code>eAddDumpSwitchClientNotFound = 2;</code>
     */
    public static final int eAddDumpSwitchClientNotFound_VALUE = 2;
    /**
     * <code>eAddDumpSwitchUnknownFail = 3;</code>
     */
    public static final int eAddDumpSwitchUnknownFail_VALUE = 3;
    /**
     * <code>eAddDumpSwitchCreateRcvGroupFail = 4;</code>
     */
    public static final int eAddDumpSwitchCreateRcvGroupFail_VALUE = 4;
    /**
     * <code>eAddDumpSwitchCreateMapRcvGroupFail = 5;</code>
     */
    public static final int eAddDumpSwitchCreateMapRcvGroupFail_VALUE = 5;
    /**
     * <code>eAddDumpSwitchValidatePortFail = 6;</code>
     */
    public static final int eAddDumpSwitchValidatePortFail_VALUE = 6;
    /**
     * <code>eAddDumpSwitchAddRtpRuleFail = 7;</code>
     */
    public static final int eAddDumpSwitchAddRtpRuleFail_VALUE = 7;
    /**
     * <code>eAddDumpSwitchAddRtcpRuleFail = 8;</code>
     */
    public static final int eAddDumpSwitchAddRtcpRuleFail_VALUE = 8;
    /**
     * <code>eAddDumpSwitchInnerError = 9;</code>
     */
    public static final int eAddDumpSwitchInnerError_VALUE = 9;
    /**
     * <code>eAddDumpSwitchRcvPortIpNotFound = 10;</code>
     */
    public static final int eAddDumpSwitchRcvPortIpNotFound_VALUE = 10;
    /**
     * <code>eAddDumpSwitchSwitchExisted = 11;</code>
     */
    public static final int eAddDumpSwitchSwitchExisted_VALUE = 11;
    /**
     * <code>eAddDumpSwitchInvalidClient = 12;</code>
     */
    public static final int eAddDumpSwitchInvalidClient_VALUE = 12;


    public final int getNumber() { return value; }

    public static EAddDumpSwitchResultCode valueOf(int value) {
      switch (value) {
        case 0: return eAddDumpSwitchSucceed;
        case 1: return eAddDumpSwitchInvalidParam;
        case 2: return eAddDumpSwitchClientNotFound;
        case 3: return eAddDumpSwitchUnknownFail;
        case 4: return eAddDumpSwitchCreateRcvGroupFail;
        case 5: return eAddDumpSwitchCreateMapRcvGroupFail;
        case 6: return eAddDumpSwitchValidatePortFail;
        case 7: return eAddDumpSwitchAddRtpRuleFail;
        case 8: return eAddDumpSwitchAddRtcpRuleFail;
        case 9: return eAddDumpSwitchInnerError;
        case 10: return eAddDumpSwitchRcvPortIpNotFound;
        case 11: return eAddDumpSwitchSwitchExisted;
        case 12: return eAddDumpSwitchInvalidClient;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EAddDumpSwitchResultCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EAddDumpSwitchResultCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EAddDumpSwitchResultCode>() {
            public EAddDumpSwitchResultCode findValueByNumber(int number) {
              return EAddDumpSwitchResultCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(22);
    }

    private static final EAddDumpSwitchResultCode[] VALUES = values();

    public static EAddDumpSwitchResultCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EAddDumpSwitchResultCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.EAddDumpSwitchResultCode)
  }

  /**
   * Protobuf enum {@code com.kedacom.ops.flink.etl.proto.ERmDumpSwitchResultCode}
   */
  public enum ERmDumpSwitchResultCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>eRmDumpSwitchSucceed = 0;</code>
     */
    eRmDumpSwitchSucceed(0, 0),
    /**
     * <code>eRmDumpSwitchInvalidParam = 1;</code>
     */
    eRmDumpSwitchInvalidParam(1, 1),
    /**
     * <code>eRmDumpSwitchClientNotFound = 2;</code>
     */
    eRmDumpSwitchClientNotFound(2, 2),
    /**
     * <code>eRmDumpSwitchUnknownFail = 3;</code>
     */
    eRmDumpSwitchUnknownFail(3, 3),
    /**
     * <code>eRmDumpSwitchRcvPortIpNotFound = 4;</code>
     */
    eRmDumpSwitchRcvPortIpNotFound(4, 4),
    /**
     * <code>eRmDumpSwitchRcvPortNotFoundOnWorker = 5;</code>
     */
    eRmDumpSwitchRcvPortNotFoundOnWorker(5, 5),
    /**
     * <code>eRmDumpSwitchRuleNotFound = 6;</code>
     */
    eRmDumpSwitchRuleNotFound(6, 6),
    /**
     * <code>eRmDumpSwitchInvalidClient = 7;</code>
     */
    eRmDumpSwitchInvalidClient(7, 7),
    ;

    /**
     * <code>eRmDumpSwitchSucceed = 0;</code>
     */
    public static final int eRmDumpSwitchSucceed_VALUE = 0;
    /**
     * <code>eRmDumpSwitchInvalidParam = 1;</code>
     */
    public static final int eRmDumpSwitchInvalidParam_VALUE = 1;
    /**
     * <code>eRmDumpSwitchClientNotFound = 2;</code>
     */
    public static final int eRmDumpSwitchClientNotFound_VALUE = 2;
    /**
     * <code>eRmDumpSwitchUnknownFail = 3;</code>
     */
    public static final int eRmDumpSwitchUnknownFail_VALUE = 3;
    /**
     * <code>eRmDumpSwitchRcvPortIpNotFound = 4;</code>
     */
    public static final int eRmDumpSwitchRcvPortIpNotFound_VALUE = 4;
    /**
     * <code>eRmDumpSwitchRcvPortNotFoundOnWorker = 5;</code>
     */
    public static final int eRmDumpSwitchRcvPortNotFoundOnWorker_VALUE = 5;
    /**
     * <code>eRmDumpSwitchRuleNotFound = 6;</code>
     */
    public static final int eRmDumpSwitchRuleNotFound_VALUE = 6;
    /**
     * <code>eRmDumpSwitchInvalidClient = 7;</code>
     */
    public static final int eRmDumpSwitchInvalidClient_VALUE = 7;


    public final int getNumber() { return value; }

    public static ERmDumpSwitchResultCode valueOf(int value) {
      switch (value) {
        case 0: return eRmDumpSwitchSucceed;
        case 1: return eRmDumpSwitchInvalidParam;
        case 2: return eRmDumpSwitchClientNotFound;
        case 3: return eRmDumpSwitchUnknownFail;
        case 4: return eRmDumpSwitchRcvPortIpNotFound;
        case 5: return eRmDumpSwitchRcvPortNotFoundOnWorker;
        case 6: return eRmDumpSwitchRuleNotFound;
        case 7: return eRmDumpSwitchInvalidClient;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ERmDumpSwitchResultCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<ERmDumpSwitchResultCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ERmDumpSwitchResultCode>() {
            public ERmDumpSwitchResultCode findValueByNumber(int number) {
              return ERmDumpSwitchResultCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return Dssevenum.getDescriptor().getEnumTypes().get(23);
    }

    private static final ERmDumpSwitchResultCode[] VALUES = values();

    public static ERmDumpSwitchResultCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private ERmDumpSwitchResultCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:com.kedacom.ops.flink.etl.proto.ERmDumpSwitchResultCode)
  }


  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    String[] descriptorData = {
      "\n\017dssevenum.proto\022\037com.kedacom.ops.flink" +
      ".etl.proto*\351\033\n\013CltDssEvent\022\033\n\027CLT_DSS_CR" +
      "EATCLIENT_REQ\020\000\022\033\n\027DSS_CLT_CREATCLIENT_A" +
      "CK\020\001\022\034\n\030DSS_CLT_CREATCLIENT_NACK\020\002\022\035\n\031CL" +
      "T_DSS_DESTROYCLIENT_REQ\020\003\022\035\n\031DSS_CLT_DES" +
      "TROYCLIENT_ACK\020\004\022\036\n\032DSS_CLT_DESTROYCLIEN" +
      "T_NACK\020\005\022\"\n\036CLT_DSS_SYNCAPPLYLOCALPORT_R" +
      "EQ\020\006\022\"\n\036DSS_CLT_SYNCAPPLYLOCALPORT_ACK\020\007" +
      "\022#\n\037DSS_CLT_SYNCAPPLYLOCALPORT_NACK\020\010\022#\n" +
      "\037CLT_DSS_ASYNCAPPLYLOCALPORT_REQ\020\t\022#\n\037DS",
      "S_CLT_ASYNCAPPLYLOCALPORT_ACK\020\n\022$\n DSS_C" +
      "LT_ASYNCAPPLYLOCALPORT_NACK\020\013\022$\n CLT_DSS" +
      "_SYNCAPPLYCARRIERPORT_REQ\020\014\022$\n DSS_CLT_S" +
      "YNCAPPLYCARRIERPORT_ACK\020\r\022%\n!DSS_CLT_SYN" +
      "CAPPLYCARRIERPORT_NACK\020\016\022%\n!CLT_DSS_ASYN" +
      "CAPPLYCARRIERPORT_REQ\020\017\022%\n!DSS_CLT_ASYNC" +
      "APPLYCARRIERPORT_ACK\020\020\022&\n\"DSS_CLT_ASYNCA" +
      "PPLYCARRIERPORT_NACK\020\021\022\033\n\027CLT_DSS_RELEAS" +
      "EPORT_REQ\020\022\022\033\n\027DSS_CLT_RELEASEPORT_ACK\020\023" +
      "\022\034\n\030DSS_CLT_RELEASEPORT_NACK\020\024\022\031\n\025CLT_DS",
      "S_ADDSWITCH_REQ\020\025\022\031\n\025DSS_CLT_ADDSWITCH_A" +
      "CK\020\026\022\032\n\026DSS_CLT_ADDSWITCH_NACK\020\027\022\034\n\030CLT_" +
      "DSS_REMOVESWITCH_REQ\020\030\022\034\n\030DSS_CLT_REMOVE" +
      "SWITCH_ACK\020\031\022\035\n\031DSS_CLT_REMOVESWITCH_NAC" +
      "K\020\032\022\036\n\032CLT_DSS_ADDM2ONESWITCH_REQ\020\033\022\036\n\032D" +
      "SS_CLT_ADDM2ONESWITCH_ACK\020\034\022\037\n\033DSS_CLT_A" +
      "DDM2ONESWITCH_NACK\020\035\022!\n\035CLT_DSS_REMOVEM2" +
      "ONESWITCH_REQ\020\036\022!\n\035DSS_CLT_REMOVEM2ONESW" +
      "ITCH_ACK\020\037\022\"\n\036DSS_CLT_REMOVEM2ONESWITCH_" +
      "NACK\020 \022\027\n\023CLT_DSS_ADDDUMP_REQ\020!\022\027\n\023DSS_C",
      "LT_ADDDUMP_ACK\020\"\022\030\n\024DSS_CLT_ADDDUMP_NACK" +
      "\020#\022\032\n\026CLT_DSS_REMOVEDUMP_REQ\020$\022\032\n\026DSS_CL" +
      "T_REMOVEDUMP_ACK\020%\022\033\n\027DSS_CLT_REMOVEDUMP" +
      "_NACK\020&\022\035\n\031CLT_DSS_SYNCADDBRIDGE_REQ\020\'\022\035" +
      "\n\031DSS_CLT_SYNCADDBRIDGE_ACK\020(\022\036\n\032DSS_CLT" +
      "_SYNCADDBRIDGE_NACK\020)\022\036\n\032CLT_DSS_ASYNCAD" +
      "DBRIDGE_REQ\020*\022\036\n\032DSS_CLT_ASYNCADDBRIDGE_" +
      "ACK\020+\022\037\n\033DSS_CLT_ASYNCADDBRIDGE_NACK\020,\022\034" +
      "\n\030CLT_DSS_REMOVEBRIDGE_REQ\020-\022\034\n\030DSS_CLT_" +
      "REMOVEBRIDGE_ACK\020.\022\035\n\031DSS_CLT_REMOVEBRID",
      "GE_NACK\020/\022\034\n\030CLT_DSS_SENDTOBRIDGE_REQ\0200\022" +
      "\034\n\030DSS_CLT_SENDTOBRIDGE_ACK\0201\022\035\n\031DSS_CLT" +
      "_SENDTOBRIDGE_NACK\0202\022 \n\034CLT_DSS_STOPSEND" +
      "TOBRIDGE_REQ\0203\022 \n\034DSS_CLT_STOPSENDTOBRID" +
      "GE_ACK\0204\022!\n\035DSS_CLT_STOPSENDTOBRIDGE_NAC" +
      "K\0205\022!\n\035CLT_DSS_RECEIVEFROMBRIDGE_REQ\0206\022!" +
      "\n\035DSS_CLT_RECEIVEFROMBRIDGE_ACK\0207\022\"\n\036DSS" +
      "_CLT_RECEIVEFROMBRIDGE_NACK\0208\022%\n!CLT_DSS" +
      "_STOPRECEIVEFROMBRIDGE_REQ\0209\022%\n!DSS_CLT_" +
      "STOPRECEIVEFROMBRIDGE_ACK\020:\022&\n\"DSS_CLT_S",
      "TOPRECEIVEFROMBRIDGE_NACK\020;\022\027\n\023DSS_CLT_S" +
      "RVLOST_NTF\020<\022\020\n\014DSS_CLT_PING\020=\022\020\n\014CLT_DS" +
      "S_PONG\020>\022\033\n\027CLT_DSS_ALIVEDETECT_REQ\020?\022\033\n" +
      "\027DSS_CLT_ALIVEDETECT_RSP\020@\022\033\n\027DSS_CLT_SR" +
      "VREGISTER_NTF\020A\022\035\n\031CLT_DSS_CONNECTMASTER" +
      "_REQ\020B\022\035\n\031DSS_CLT_CONNECTMASTER_ACK\020C\022\036\n" +
      "\032DSS_CLT_CONNECTMASTER_NACK\020D\022\020\n\014DSS_CLT" +
      "_PONG\020E\022\020\n\014CLT_DSS_PING\020F\022!\n\035CLT_DSS_GET" +
      "LOSTRATEBYPORT_REQ\020G\022#\n\037DSS_CLT_GETLOSTR" +
      "ATEBYPORT_REPLY\020H\022#\n\037CLT_DSS_BINDWORKERT",
      "OMEETING_REQ\020I\022#\n\037DSS_CLT_BINDWORKERTOME" +
      "ETING_ACK\020J\022$\n DSS_CLT_BINDWORKERTOMEETI" +
      "NG_NACK\020K\022\'\n#CLT_DSS_UNBINDWORKERFROMMEE" +
      "TING_REQ\020L\022\'\n#DSS_CLT_UNBINDWORKERFROMME" +
      "ETING_ACK\020N\022(\n$DSS_CLT_UNBINDWORKERFROMM" +
      "EETING_NACK\020O\022\034\n\030DSS_CLT_REMOVECLIENT_NT" +
      "F\020P\022\035\n\031CLT_DSS_SYNCAPPLYPORT_REQ\020Q\022\035\n\031DS" +
      "S_CLT_SYNCAPPLYPORT_ACK\020R\022\036\n\032DSS_CLT_SYN" +
      "CAPPLYPORT_NACK\020S\022\036\n\032CLT_DSS_ASYNCAPPLYP" +
      "ORT_REQ\020T\022\036\n\032DSS_CLT_ASYNCAPPLYPORT_ACK\020",
      "U\022\037\n\033DSS_CLT_ASYNCAPPLYPORT_NACK\020V\022$\n DS" +
      "S_CLT_BRIDGESPEAKERREMOVED_NTF\020W\022#\n\037CLT_" +
      "DSS_DESTROYCLIENTBYUUID_REQ\020X\022#\n\037DSS_CLT" +
      "_DESTROYCLIENTBYUUID_ACK\020Y\022$\n DSS_CLT_DE" +
      "STROYCLIENTBYUUID_NACK\020Z\022!\n\035CLT_DSS_RELE" +
      "ASEPORTBYUUID_REQ\020[\022!\n\035DSS_CLT_RELEASEPO" +
      "RTBYUUID_ACK\020\\\022\"\n\036DSS_CLT_RELEASEPORTBYU" +
      "UID_NACK\020]\022\"\n\036CLT_DSS_REMOVEBRIDGEBYUUID" +
      "_REQ\020^\022\"\n\036DSS_CLT_REMOVEBRIDGEBYUUID_ACK" +
      "\020_\022#\n\037DSS_CLT_REMOVEBRIDGEBYUUID_NACK\020`\022",
      "\032\n\026CLT_DSS_SRVLOST_NTFRSP\020a\022\036\n\032CLT_DSS_S" +
      "RVREGISTER_NTFRSP\020b\022\037\n\033CLT_DSS_RELEASEPA" +
      "RTPORT_REQ\020c\022\036\n\032DSS_CLT_RELEASEPARPORT_A" +
      "CK\020d\022\037\n\033DSS_CLT_RELEASEPARPORT_NACK\020e\022&\n" +
      "\"DSS_CLT_DYNAMICENCRPTYKEYLENSS_NTF\020f\022\'\n" +
      "#CLT_DSS_UPDATEDYNAMICENCRPTYKEY_CMD\020g\022\032" +
      "\n\026CLT_DSS_SET_EPMUTE_REQ\020h\022\032\n\026DSS_CLT_SE" +
      "T_EPMUTE_ACK\020i\022\033\n\027DSS_CLT_SET_EPMUTE_NAC" +
      "K\020j\022\034\n\030CLT_DSS_SET_EPSILENT_REQ\020k\022\034\n\030DSS" +
      "_CLT_SET_EPSILENT_ACK\020l\022\035\n\031DSS_CLT_SET_E",
      "PSILENT_NACK\020m*2\n\007EIpType\022\021\n\rIpTypeUnkno" +
      "wn\020\000\022\t\n\005eIpV4\020\001\022\t\n\005eIpV6\020\002*P\n\013EClientTyp" +
      "e\022\021\n\rDssObjUnknown\020\000\022\014\n\010DSS_CONF\020\001\022\n\n\006DS" +
      "S_NU\020\002\022\024\n\020DSS_PSEUDOCLIENT\020\003*C\n\013ESwitchT" +
      "ype\022\021\n\rDsTypeUnknown\020\000\022\t\n\005DSRTP\020\001\022\n\n\006DSR" +
      "TCP\020\002\022\n\n\006DSDUMP\020\003*\201\001\n\021ESwitchStreamType\022" +
      "\026\n\022StreamType_Unknown\020\000\022\032\n\026SwitchStreamT" +
      "ype_AUDIO\020\001\022\032\n\026SwitchStreamType_VIDEO\020\002\022" +
      "\034\n\030SwitchStreamType_224DATA\020\003*d\n\024ESwitch" +
      "DirectionType\022\024\n\020DSDIRECTION_NONE\020\000\022\033\n\027D",
      "SDIRECTION_DOWN_SWITCH\020\001\022\031\n\025DSDIRECTION_" +
      "UP_SWITCH\020\002*\211\001\n\010ESecMode\022\021\n\rSEC_MODE_NON" +
      "E\020\000\022\020\n\014SEC_MODE_ECB\020\001\022\020\n\014SEC_MODE_CBC\020\002\022" +
      "\020\n\014SEC_MODE_CFB\020\003\022\020\n\014SEC_MODE_OFB\020\004\022\020\n\014S" +
      "EC_MODE_MAC\020\005\022\020\n\014SEC_MODE_CTR\020\006*\205\002\n\007ESec" +
      "Alg\022\020\n\014SEC_ALG_NONE\020\000\022\017\n\013SEC_ALG_SM1\020\001\022\021" +
      "\n\rSEC_ALG_SSF33\020\002\022\017\n\013SEC_ALG_SM4\020\003\022\017\n\013SE" +
      "C_ALG_DES\020\004\022\017\n\013SEC_ALG_AES\020\005\022\020\n\014SEC_ALG_" +
      "3DES\020\006\022\017\n\013SEC_ALG_RSA\020\007\022\021\n\rSEC_ALG_SM2_1" +
      "\020\010\022\021\n\rSEC_ALG_SM2_2\020\t\022\021\n\rSEC_ALG_SM2_3\020\n",
      "\022\017\n\013SEC_ALG_SM3\020\013\022\020\n\014SEC_ALG_SHA1\020\014\022\022\n\016S" +
      "EC_ALG_SHA256\020\r*&\n\022EDssInitResultCode\022\020\n" +
      "\014eInitSucceed\020\000*\201\004\n\030EDssCarrierReqResult" +
      "Code\022\023\n\017eCarrierSucceed\020\000\022\030\n\024eCarrierInv" +
      "alidParam\020\001\022\032\n\026eCarrierClientNotFound\020\002\022" +
      "\023\n\017eCarrierTimeOut\020\003\022\027\n\023eCarrierUnknownF" +
      "ail\020\004\022\030\n\024eCarrierAsyncSucceed\020\005\022\034\n\030eCarr" +
      "ierPortnumNotEnough\020\006\022\036\n\032eCarrierBandwid" +
      "thNotEnough\020\007\022$\n eCarrierSpecifiedCarrie" +
      "rNotExist\020\010\022\'\n#eCarrierSpecifiedCarrierD",
      "mzNotExist\020\t\022 \n\034eCarrierConsPortnumNotEn" +
      "ough\020\n\022\031\n\025eCarrierInvalidClient\020\013\022#\n\037eCa" +
      "rrierSpecifiedWorkerNotFound\020\014\022\035\n\031eCarri" +
      "erNoAvailableWorker\020\r\022#\n\037eCarrierWorkerR" +
      "esourceExhausted\020\016\022\037\n\033eCarrierPortHandle" +
      "Exhausted\020\017*\224\004\n\026EDssLocalReqResultCode\022\021" +
      "\n\reLocalSucceed\020\000\022\026\n\022eLocalInvalidParam\020" +
      "\001\022\030\n\024eLocalClientNotFound\020\002\022\021\n\reLocalTim" +
      "eOut\020\003\022\025\n\021eLocalUnknownFail\020\004\022\026\n\022eLocalA" +
      "syncSucceed\020\005\022\032\n\026eLocalPortnumNotEnough\020",
      "\006\022\034\n\030eLocalBandwidthNotEnough\020\007\022\025\n\021eLoca" +
      "lNoLocalAddr\020\010\022\036\n\032eLocalConsPortnumNotEn" +
      "ough\020\t\022\027\n\023eLocalInvalidClient\020\n\022\"\n\036eLoca" +
      "lSpecifiedCarrierNotExist\020\013\022%\n!eLocalSpe" +
      "cifiedCarrierDmzNotExist\020\014\022\034\n\030eLocalNoWo" +
      "rkerRegistered\020\r\022!\n\035eLocalSpecifiedWorke" +
      "rNotFound\020\016\022\033\n\027eLocalNoAvailableWorker\020\017" +
      "\022!\n\035eLocalWorkerResourceExhausted\020\020\022\035\n\031e" +
      "LocalPortHandleExhausted\020\021*\240\004\n\027EDssApply" +
      "PortResultCode\022\025\n\021eApplyPortSucceed\020\000\022\032\n",
      "\026eApplyPortInvalidParam\020\001\022\034\n\030eApplyPortC" +
      "lientNotFound\020\002\022\025\n\021eApplyPortTimeOut\020\003\022\031" +
      "\n\025eApplyPortUnknownFail\020\004\022\032\n\026eApplyPortA" +
      "syncSucceed\020\005\022\036\n\032eApplyPortPortnumNotEno" +
      "ugh\020\006\022 \n\034eApplyPortBandwidthNotEnough\020\007\022" +
      "&\n\"eApplyPortSpecifiedCarrierNotExist\020\010\022" +
      ")\n%eApplyPortSpecifiedCarrierDmzNotExist" +
      "\020\t\022\"\n\036eApplyPortConsPortnumNotEnough\020\n\022\033" +
      "\n\027eApplyPortInvalidClient\020\013\022%\n!eApplyPor" +
      "tSpecifiedWorkerNotFound\020\014\022\037\n\033eApplyPort",
      "NoAvailableWorker\020\r\022%\n!eApplyPortWorkerR" +
      "esourceExhausted\020\016\022!\n\035eApplyPortPortHand" +
      "leExhausted\020\017*\311\001\n\027EDssAddBridgeResultCod" +
      "e\022\025\n\021eAddBridgeSucceed\020\000\022\037\n\033eAddBridgeNo" +
      "WorkerInMeeting\020\001\022\033\n\027eAddBridgePortNotEn" +
      "ough\020\002\022\033\n\027eAddBridgeInvalidClient\020\003\022\033\n\027e" +
      "AddBridgeNewBridgeFail\020\004\022\037\n\033eAddBridgeNe" +
      "wBridgeNodeFail\020\005*`\n\026EDssRmBridgeResultC" +
      "ode\022\024\n\020eRmBridgeSucceed\020\000\022\024\n\020eRmBridgeUn" +
      "known\020\001\022\032\n\026eRmBridgeInvalidClient\020\002*\320\002\n\027",
      "ESendToBridgeResultCode\022\030\n\024eSendToBridge" +
      "Succeed\020\000\022%\n!eSendToBridgeBridgeHandleNo" +
      "tFound\020\001\022#\n\037eSendToBridgeBridgeHeadNotFo" +
      "und\020\002\022!\n\035eSendToBridgeWorkerIpNotFound\020\003" +
      "\022\"\n\036eSendToBridgeSwitchRuleExisted\020\004\022\"\n\036" +
      "eSendToBridgeAddSwitchRuleFail\020\005\022#\n\037eSen" +
      "dToBridgeCreateRcvGroupFail\020\006\022\036\n\032eSendTo" +
      "BridgeInvalidClient\020\007\022\037\n\033eSendToBridgeGe" +
      "tMeetingFail\020\010*\344\003\n\033EStopSendToBridgeResu" +
      "ltCode\022\034\n\030eStopSendToBridgeSucceed\020\000\022)\n%",
      "eStopSendToBridgeBridgeHandleNotFound\020\001\022" +
      "\'\n#eStopSendToBridgeBridgeHeadNotFound\020\002" +
      "\022%\n!eStopSendToBridgeWorkerIpNotFound\020\003\022" +
      "\'\n#eStopSendToBridgeSwitchRuleNotExist\020\004" +
      "\022&\n\"eStopSendToBridgeAddSwitchRuleFail\020\005" +
      "\022(\n$eStopSendToBridgeDestroyRcvGroupFail" +
      "\020\006\022%\n!eStopSendToBridgeRcvGroupNotFound\020" +
      "\007\022\"\n\036eStopSendToBridgeInvalidClient\020\010\022#\n" +
      "\037eStopSendToBridgeGetMeetingFail\020\t\022\"\n\036eS" +
      "topSendToBridgeGetBridgeFail\020\n\022\035\n\031eStopS",
      "endToBridgeStopFail\020\013*\261\004\n\034EReceiveFromBr" +
      "idgeResultCode\022\035\n\031eReceiveFromBridgeSucc" +
      "eed\020\000\0220\n,eReceiveFromBridgeFailToPullWor" +
      "kerIntoBridge\020\001\0223\n/eReceiveFromBridgeFai" +
      "lToGetBridgeNodeFromBridge\020\002\022*\n&eReceive" +
      "FromBridgeBridgeHandleNotFound\020\003\022(\n$eRec" +
      "eiveFromBridgeBridgeHeadNotFound\020\004\022&\n\"eR" +
      "eceiveFromBridgeWorkerIpNotFound\020\005\022\'\n#eR" +
      "eceiveFromBridgeSwitchRuleExisted\020\006\022\'\n#e" +
      "ReceiveFromBridgeAddSwitchRuleFail\020\007\022(\n$",
      "eReceiveFromBridgeCreateRcvGroupFail\020\010\022#" +
      "\n\037eReceiveFromBridgeInvalidClient\020\t\022$\n e" +
      "ReceiveFromBridgeGetMeetingFail\020\n\022#\n\037eRe" +
      "ceiveFromBridgeGetBridgeFail\020\013\022!\n\035eRecei" +
      "veFromBridgeReceiveFail\020\014*\251\004\n EStopRecei" +
      "veFromBridgeResultCode\022!\n\035eStopReceiveFr" +
      "omBridgeSucceed\020\000\022.\n*eStopReceiveFromBri" +
      "dgeBridgeHandleNotFound\020\001\022,\n(eStopReceiv" +
      "eFromBridgeBridgeHeadNotFound\020\002\022*\n&eStop" +
      "ReceiveFromBridgeWorkerIpNotFound\020\003\022,\n(e",
      "StopReceiveFromBridgeSwitchRuleNotExist\020" +
      "\004\022,\n(eStopReceiveFromBridgeFindSwitchRul" +
      "eFail\020\005\022-\n)eStopReceiveFromBridgeDestroy" +
      "RcvGroupFail\020\006\022*\n&eStopReceiveFromBridge" +
      "RcvGroupNotFound\020\007\022\'\n#eStopReceiveFromBr" +
      "idgeInvalidClient\020\010\022(\n$eStopReceiveFromB" +
      "ridgeGetMeetingFail\020\t\022\'\n#eStopReceiveFro" +
      "mBridgeGetBridgeFail\020\n\022%\n!eStopReceiveFr" +
      "omBridgeReceiveFail\020\013*\233\003\n\024EAddSwitchResu" +
      "ltCode\022\025\n\021eAddSwitchSucceed\020\000\022\032\n\026eAddSwi",
      "tchInvalidParam\020\001\022\034\n\030eAddSwitchClientNot" +
      "Found\020\002\022\031\n\025eAddSwitchUnknownFail\020\003\022 \n\034eA" +
      "ddSwitchCreateRcvGroupFail\020\004\022#\n\037eAddSwit" +
      "chCreateMapRcvGroupFail\020\005\022\036\n\032eAddSwitchV" +
      "alidatePortFail\020\006\022\034\n\030eAddSwitchAddRtpRul" +
      "eFail\020\007\022\035\n\031eAddSwitchAddRtcpRuleFail\020\010\022\030" +
      "\n\024eAddSwitchInnerError\020\t\022\037\n\033eAddSwitchRc" +
      "vPortIpNotFound\020\n\022\033\n\027eAddSwitchSwitchExi" +
      "sted\020\013\022\033\n\027eAddSwitchInvalidClient\020\014*\376\001\n\023" +
      "ERmSwitchResultCode\022\024\n\020eRmSwitchSucceed\020",
      "\000\022\031\n\025eRmSwitchInvalidParam\020\001\022\033\n\027eRmSwitc" +
      "hClientNotFound\020\002\022\030\n\024eRmSwitchUnknownFai" +
      "l\020\003\022\036\n\032eRmSwitchRcvPortIpNotFound\020\004\022$\n e" +
      "RmSwitchRcvPortNotFoundOnWorker\020\005\022\035\n\031eRm" +
      "SwitchSwitchNotExisted\020\006\022\032\n\026eRmSwitchInv" +
      "alidClient\020\007*\341\003\n\031EAddM2OneSwitchResultCo" +
      "de\022\032\n\026eAddM2OneSwitchSucceed\020\000\022\037\n\033eAddM2" +
      "OneSwitchInvalidParam\020\001\022!\n\035eAddM2OneSwit" +
      "chClientNotFound\020\002\022\036\n\032eAddM2OneSwitchUnk" +
      "nownFail\020\003\022%\n!eAddM2OneSwitchCreateRcvGr",
      "oupFail\020\004\022(\n$eAddM2OneSwitchCreateMapRcv" +
      "GroupFail\020\005\022#\n\037eAddM2OneSwitchValidatePo" +
      "rtFail\020\006\022!\n\035eAddM2OneSwitchAddRtpRuleFai" +
      "l\020\007\022\"\n\036eAddM2OneSwitchAddRtcpRuleFail\020\010\022" +
      "\035\n\031eAddM2OneSwitchInnerError\020\t\022$\n eAddM2" +
      "OneSwitchRcvPortIpNotFound\020\n\022 \n\034eAddM2On" +
      "eSwitchSwitchExisted\020\013\022 \n\034eAddM2OneSwitc" +
      "hInvalidClient\020\014*\320\002\n\030ERmM2OneSwitchResul" +
      "tCode\022\031\n\025eRmM2OneSwitchSucceed\020\000\022\036\n\032eRmM" +
      "2OneSwitchInvalidParam\020\001\022 \n\034eRmM2OneSwit",
      "chClientNotFound\020\002\022\035\n\031eRmM2OneSwitchUnkn" +
      "ownFail\020\003\022#\n\037eRmM2OneSwitchRcvPortIpNotF" +
      "ound\020\004\022)\n%eRmM2OneSwitchRcvPortNotFoundO" +
      "nWorker\020\005\022\036\n\032eRmM2OneSwitchRuleNotFound\020" +
      "\006\022\'\n#eRmM2OneSwitchFoundRuleByRcvDstFail" +
      "\020\007\022\037\n\033eRmM2OneSwitchInvalidClient\020\010*\323\003\n\030" +
      "EAddDumpSwitchResultCode\022\031\n\025eAddDumpSwit" +
      "chSucceed\020\000\022\036\n\032eAddDumpSwitchInvalidPara" +
      "m\020\001\022 \n\034eAddDumpSwitchClientNotFound\020\002\022\035\n" +
      "\031eAddDumpSwitchUnknownFail\020\003\022$\n eAddDump",
      "SwitchCreateRcvGroupFail\020\004\022\'\n#eAddDumpSw" +
      "itchCreateMapRcvGroupFail\020\005\022\"\n\036eAddDumpS" +
      "witchValidatePortFail\020\006\022 \n\034eAddDumpSwitc" +
      "hAddRtpRuleFail\020\007\022!\n\035eAddDumpSwitchAddRt" +
      "cpRuleFail\020\010\022\034\n\030eAddDumpSwitchInnerError" +
      "\020\t\022#\n\037eAddDumpSwitchRcvPortIpNotFound\020\n\022" +
      "\037\n\033eAddDumpSwitchSwitchExisted\020\013\022\037\n\033eAdd" +
      "DumpSwitchInvalidClient\020\014*\236\002\n\027ERmDumpSwi" +
      "tchResultCode\022\030\n\024eRmDumpSwitchSucceed\020\000\022" +
      "\035\n\031eRmDumpSwitchInvalidParam\020\001\022\037\n\033eRmDum",
      "pSwitchClientNotFound\020\002\022\034\n\030eRmDumpSwitch" +
      "UnknownFail\020\003\022\"\n\036eRmDumpSwitchRcvPortIpN" +
      "otFound\020\004\022(\n$eRmDumpSwitchRcvPortNotFoun" +
      "dOnWorker\020\005\022\035\n\031eRmDumpSwitchRuleNotFound" +
      "\020\006\022\036\n\032eRmDumpSwitchInvalidClient\020\007"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
      new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {
        public com.google.protobuf.ExtensionRegistry assignDescriptors(
            com.google.protobuf.Descriptors.FileDescriptor root) {
          descriptor = root;
          return null;
        }
      };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        }, assigner);
  }

  // @@protoc_insertion_point(outer_class_scope)
}
